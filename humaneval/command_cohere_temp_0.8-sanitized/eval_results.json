{"date": "2024-09-03 21:29", "hash": "fe585eb4df8c88d844eeb463ea4d0302", "eval": {"HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Optional\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter a given list of any Python values only for integers.\n\n    :param values: List of any Python values.\n    :return: A list of integers contained in the input list.\n    \"\"\"\n    integers: List[int] = []\n    for value in values:\n        if isinstance(value, int):\n            integers.append(value)\n    return integers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\nimport numpy as np\nimport unittest\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    return np.mean(np.abs(np.array(numbers) - np.mean(np.array(numbers))))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-2.0, 1.0, 1.0, 2.0, 2.0, 2.0, -2.0, 2.7500345836492754, 1.2120988051006742]]]}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "def greatest_common_divisor(a, b):\n    \"\"\" Returns the greatest common divisor of two integers a and b \"\"\"\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    return greatest_common_divisor(b%a, a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n, p):\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    avg = (n + m) // 2\n    if n > m:\n        return -1\n    rounded = avg % 1\n    binary = bin(rounded)[2:]\n    return binary if binary else '0b0'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 5]], "plus_fail_tests": [[1, 1]]}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    s = str(x)\n    digit_count = len(s)\n    if shift > digit_count:\n        shift = digit_count\n    return s[-shift:] + s[:-shift]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[16, 3]]}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    binary_str = \"{0:b}\".format(decimal)\n    return \"db{0}db\".format(binary_str)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n\n    for char in string:\n        index = alphabet.find(char)\n        encrypted += alphabet[(index + 2) % 26]\n\n    return encrypted", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["hi"]], "plus_fail_tests": [["abcde"]]}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given a list of numbers (at least two elements), apply a linear transform to that list,\n        such that the smallest number will become 0 and the largest will become 1 \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [((x - min_value) / (max_value - min_value)) for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    return (sum(numbers), sum(x * y for x, y in zip(numbers, numbers[1:])) if len(numbers) > 1 else numbers[0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 1]]], "plus_fail_tests": [[[2, 4, 6, 8, 10]]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    nums = [int(i) for i in arr]\n    counts = 0\n    for n in nums:\n        if sum(int(d) for d in str(n)) > 0:\n            counts += 1\n    return counts", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    freq, max_val = -1, 0 \n    for val in lst:\n        if val > max_val:\n            max_val = val \n        elif val == max_val and lst.count(val) >= val:\n            freq = val \n    return max_val if freq >= max_val else -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 5, 5, 5, 1]]], "plus_fail_tests": [[[3, 2, 1, 1, 1, 1, 1]]]}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    char_count = {}\n    max_char_word = None\n    for word in words:\n        unique_chars = set(word)\n        char_count[word] = len(unique_chars)\n        if max_char_word is None or char_count[word] > char_count[max_char_word]:\n            max_char_word = word\n    return max_char_word", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["name", "enam", "game"]]], "plus_fail_tests": [[["xyz", "pqr"]]]}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int):\n    # Define two lists to store the positions of left and right driving cars.\n    left_driving = [i for i in range(n)]\n    right_driving = [i for i in range(n, 2 * n)]\n\n    # Find intersections between the two lists. These are the colliding cars.\n    collisions = list(set(left_driving) & set(right_driving))\n\n    # If there are no collisions, return 0.\n    if not collisions:\n        return 0\n    \n    # If there are collisions, return the number of collisions.\n    return len(collisions)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"\n    Checks whether a positive integer 'n' is a prime number or not.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef intersection(s1, s2):\n    \"\"\"\n    Checks whether the length of the intersection of two given intervals is a prime number or not.\n    \"\"\"\n    # Convert interval to python intervals\n    start1, end1 = s1\n    start2, end2 = s2\n    \n    # Calculate the intersection\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if intersect_start > intersect_end:\n        return \"NO\"\n    \n    intersect_length = intersect_end - intersect_start + 1\n    \n    if is_prime(intersect_length):\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "def closest_integer(s):\n    \"\"\"\n    Return the closest integer to the given numeric string, rounding away from zero.\n\n    Args:\n        s (str): Numeric string to be converted to an integer.\n\n    Returns:\n        int: The closest integer to the input.\n    \"\"\"\n    n = float(s)\n    return round(n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["14.5"]], "plus_fail_tests": [["-6.5"]]}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\"\"\"\n    n = len(l)\n    sorted_l = sorted(l)\n    if n % 2 == 1:\n        return sorted_l[n // 2]\n    else:\n        mid1 = sorted_l[n // 2 - 1]\n        mid2 = sorted_l[n // 2]\n        return (mid1 + mid2) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets):\n    open, close = 0, 0\n    for char in brackets:\n        if char == '<':\n            open += 1\n        elif char == '>':\n            close += 1\n        if open > close:\n            return False\n    return open == close", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["<>"]], "plus_fail_tests": [["><"]]}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "import re\ndef split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',', if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u2192 [\"Hello\", \"world!\"]\n    split_words(\"Hello, world!\") \u2192 [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    \"\"\"\n    no_comma = re.findall(r'\\w+', txt)\n    if len(no_comma) > 0:\n        return re.split(r'\\s|,', txt)\n    elif ',' in txt:\n        return re.split(r',', txt)\n    else:\n        return len(re.findall(r'\\b(\\w)*(\\w)\\1\\b', txt))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello world,!"]], "plus_fail_tests": [["Hello?"]]}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    letter_count = {}\n    for letter in test.lower():\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n    return letter_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["a b b a"]], "plus_fail_tests": [["x y z x y z x"]]}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    letters_set = set(s)\n    return len(s) % 3 == 0 and len(letters_set) == len(s) - 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["abcd"]], "plus_fail_tests": [["xyz"]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs: list) -> list:\n    \"\"\"Return the derivative of a polynomial represented by coefficients xs.\"\"\"\n    n = len(xs) - 1\n    result = [0] * n\n    x = 1\n    for i in range(n):\n        result[i] = xs[i+1] * x\n        x *= 1j if i < n-1 else 1    # Handle negative exponents\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 1, 2, 4, 5]]], "plus_fail_tests": [[[0, 0, 0, 0, 0, 5]]]}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    characters = set(string.lower())\n    return len(characters)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(n, need, rem):\n    tot, lef = n, rem\n    if tot + need > rem:\n        tot += rem\n        lef = 0\n    elif tot + need == rem:\n        tot += need\n        lef = 0\n    else:\n        tot += need\n        lef = rem - (tot - n)\n    return [tot, lef]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 6, 10]], "plus_fail_tests": [[10, 0, 10]]}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def count_consonants(word):\n    \"\"\"\n    Helper function to count the number of consonants in a word.\n    \"\"\"\n    total = 0\n    for char in word:\n        if char in 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ':\n            total += 1\n    return total\ndef select_words(s, n):\n    \"\"\"\n    Returns a list of all words from string s that contain exactly n consonants, \n    in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    \"\"\"\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        consonant_count = count_consonants(word)\n        if consonant_count == n:\n            result.append(word)\n\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Python isp a popular programminPython isp a populathis is a test string with multiplePython isp a popular program ming language words containing different numbers of consonants programming  languagePython is a popular progrmming languageg language", 0]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "def digits(n):\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 == 1:\n            product *= int(digit)\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2468]], "plus_fail_tests": [[246]]}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    return list(set(numbers))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[63]]}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "import re\nfrom typing import List\ndef parse_music(music_string: str) -> List[int]:\n    # Regular expression to match a pattern of one of the four available notes.\n    NOTE_PATTERN = re.compile(r'(?P<whole_note>o)|(?P<half_note>o\\|)|(?P<quater_note>.\\.|o\\|\\.')\n    \n    # Defining a function which takes a string as an input and returns a list of integers.\n    beats = []\n    for match in NOTE_PATTERN.finditer(music_string):\n        note = match.group()\n        if note == 'o':\n            beats.append(4)\n        elif note == 'o|':\n            beats.append(2)\n        else:\n            beats.append(1)\n    return beats", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [["o o| o| o|"]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    sum_two_digits = 0\n    for i in range(k): \n        num = arr[i]\n        if len(str(num))<=2:\n            sum_two_digits += num\n    return sum_two_digits\narr = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\nk = 4", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-99, -88, -77, -66, -55, -44, -33, -22, -11], 5]]}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    \"\"\"\n    Sort the given list of integers in ascending order according to the sum of their digits,\n    with the tiebreaker being their index in the original list.\n\n    Args:\n        nums (list): List of integers to be sorted.\n\n    Returns:\n        list:Sorted list according to the specified criteria.\n    \"\"\"\n    if len(nums) == 0:\n        return []\n\n    # Track the sorting order based on sum of digits and original index.\n    sorted_order = []\n\n    # Loop through each number in the input list.\n    for i, num in enumerate(nums):\n        # Express the number as a list of digits.\n        digits = [int(x) for x in str(num)]\n        \n        # Calculate the sum of the digits.\n        digit_sum = sum(digits)\n        \n        # Add the number to the sorting order with its original index.\n        sorted_order.append((digit_sum, i))\n\n    # Sort the sorting_order list, which is our sorting key.\n    sorted_order.sort()\n\n    # Track the sorted output corresponding to the original list.\n    sorted_nums = [nums[i] for i in sorted_order[0][1]]\n\n    return sorted_nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[1, 2, 3]]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    new_text = []\n    for c in text:\n        if c == ' ':\n            if len(new_text) > 1 and new_text[-1] == ' ':\n                new_text.append('-')\n            else:\n                new_text.append('_')\n        else:\n            new_text.append(c)\n    return ''.join(new_text)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Exa   mple"]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list):\n    even = [e for e in l if e % 2 == 0]\n    odd = [e for e in l if e % 2 != 0]\n    even = sorted(even)\n    return odd + even", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": [[[2, 6, 4, 8, 10]]]}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n    if not isinstance(file_name, str):\n        return \"File name should be a string\"\n    \n    if not file_name.isalpha():\n        return \"FileName must start with a letter\"\n    \n    dot_index = file_name.find(\".\")\n    if dot_index < 0 or dot_index + 1 == len(file_name):\n        return \"File name should contain exactly one dot\"\n    \n    prefix = file_name[:dot_index]\n    \n    if not prefix.isalpha():\n        return \"File name should start with a letter\"\n    \n    if len(prefix) > 8 or len(prefix) == 0:\n        return \"The substring before the dot should have between (0-8) characters\"\n    \n    if dot_index + 2 == len(file_name):\n        return \"The file's name should have at least two characters after the dot\"\n    \n    suffix = file_name[dot_index + 1:]\n    valid_suffix = [\"txt\", \"exe\", \"dll\"]\n    if suffix not in valid_suffix:\n        return \"Valid file extensions are: txt, exe, dll\"\n    \n    digits = sum(1 for c in file_name if c.isdigit())\n    if digits > 3:\n        return \"File name should not contain more than three digits\"\n    \n    return \"Yes\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["example.txt"]], "plus_fail_tests": [["example.py"]]}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list):\n    l_copy = l.copy()\n    return [e if i % 3 != 0 else sorted(l_copy)[i // 3] for i, e in enumerate(l)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]]], "plus_fail_tests": [[[9, 12, 15, 6, 3, 8, 10, 23, 7]]]}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    fib4_list = [0, 0, 2, 0]\n    for i in range(5, n + 1):\n        fib4_list.append(fib4_list[i - 1] + fib4_list[i - 2] + fib4_list[i - 3] + fib4_list[i - 4])\n    return fib4_list[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[4]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    result = [0, 1, 3]\n    while len(result) < n + 1:\n        if len(result) % 2 == 0:\n            result.append(1 + result[-1] / 2)\n        else:\n            x = result[-1]\n            y = result[-2]\n            z = result[-3]\n            result.append(x + y + z)\n    return result[:n+1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n    even_odd = [el for i, el in enumerate(lst) if i % 2 == 1 and el % 2 == 0]\n    return sum(even_odd)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [string for string in strings if string.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    cons_count = 0\n    for char in word:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                vowel = True\n            else:\n                vowel = False\n            if not vowel and char.lower() not in 'qvwxz':\n                cons_count += 1\n        elif char.isspace():\n            continue\n        elif char.isdigit():\n            if cons_count > 0:\n                return char\n        else:\n            continue\n    if cons_count > 0 and cons_count % 2 == 1:\n        return char\n    else:\n        return ''", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["yogurt"]], "plus_fail_tests": [["hello"]]}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n    return ''.join(c.swapcase() if c.isalpha() else c for c in string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "def special_factorial(n):\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return fact", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[3]]}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    return any(abs(x - y) < threshold for x, y in zip(numbers, numbers[1:]))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.0, 2.0, 5.9, 4.0, 5.0], 0.95]], "plus_fail_tests": [[[0.1, 0.5, 1.0, 1.5, 2.0, 0.5], 0.4]]}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "import math\ndef max_fill(grid, capacity):\n    wells = len(grid)\n    rows = len(grid[0]) \n    filled_wells = 0\n    \n    for i in range(wells):\n        row = 0\n        for j in range(rows):\n            if grid[i][j] == 1:\n                filled_wells += row\n                row += 1\n            else:\n                row += capacity \n        filled_wells += row \n    \n    return filled_wells", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    result = 0\n    # Ensure that the lengths of operator and operand are compatible for proper calculations\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"Operator and operand lengths must be compatible!\")\n    # Ensure we have an operator and sufficient operands\n    if len(operator) < 1 or len(operand) < 2:\n        raise ValueError(\"Operator list must have at least one operator and operand list must have at least two operands!\")\n    # Loop through the operators and operands, building up the expression and evaluating it\n    for i in range(0, len(operand)):\n        if i > 0:\n            result += operator[i-1] * operand[i]\n        else:\n            result += operand[i]\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["**", "*", "+"], [2, 3, 4, 5]]], "plus_fail_tests": [[["+", "-", "*", "//"], [5, 2, 3, 4, 7]]]}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    \"\"\"\n    Checks whether the number is prime or not.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n    \"\"\"\n    words = sentence.split(' ')\n    result = []\n    for word in words:\n        if is_prime(len(word)):\n            result.append(word)\n    return ' '.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    result = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            num **= 2\n        elif i % 4 == 0 and i % 3 != 0:\n            num **= 3\n        result += num\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n):\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    \"\"\"\n    return ' '.join(map(str, range(n+1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n    \"\"\"\n    # Ensure a and b are either both strings or both numbers\n    try:\n        a = float(a)\n        b = float(b) if b != \"\" else float(0)\n    except ValueError:\n        a = a if a != \"\" else \"\"\n        b = b if b != \"\" else \"\"\n\n    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [["5,000", 5000]]}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def is_prime(n):\n    \"\"\"\n    Checks if a number is prime\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef prime_fib(n):\n    \"\"\"\n    Returns n-th number that is a Fibonacci number and it's also prime.\n    \"\"\"\n    # Create two variables, f and g, initialized to the first two numbers of the Fibonacci sequence\n    f = 0\n    g = 1\n    count = 0\n\n    while count < n:\n        # If f is prime, return it\n        if is_prime(f):\n            return f\n        # Generate the next Fibonacci number\n        count += 1\n        x = f + g\n        f = g\n        g = x\n\n    # If we reach this line, the desired index n is out of bounds\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[11]]}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n):\n    less_than_n = [int(x) for x in range(n - 1, 1, -1)]\n    return sum(1 for x in less_than_n if x % 11 == 0 or x % 13 == 0 and x % 7 != 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[50]], "plus_fail_tests": [[20]]}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers must be provided\")\n    else:\n        middle = len(numbers) // 2\n        left, right = numbers[middle - 1], numbers[middle]\n        return _get_closest_pair_efficient(left, right)\ndef _get_closest_pair_efficient(a, b):\n    if a == b or (a - b) < 1e-6 and (b - a) < 1e-6:\n        return a, b\n    mx = max(a, b)\n    mn = min(a, b)\n    cmn = (mx + mn) / 2\n    cmx = (mn + mx) / 2\n    acmn, bcmn = a - cmn, b - cmn\n    acmx, bcmx = a - cmx, b - cmx\n    if (abs(acmn) + abs(acmx)) < (abs(acmx) + abs(acmn)) and (abs(bcmn) + abs(bcmx)) < (abs(bcmx) + abs(bcmn)):\n        return cmn, cmx\n    else:\n        return _get_closest_pair_efficient(cmn, cmx)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.0, 2.0, 3.9, 4.0, 5.0, 2.2]]], "plus_fail_tests": [[[1.5, 2.5, 3.5, 4.5]]]}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    num1, denom1 = map(int, x.split('/'))\n    num2, denom2 = map(int, n.split('/'))\n    return num1 * denom2 == int(num1 * n / denom1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1/5", "5/1"]], "plus_fail_tests": [["3/4", "4/3"]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    even_present = any(x % 2 == 0 for x in lst1)\n    if even_present:\n        return \"YES\"\n    else:\n        return \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4]]], "plus_fail_tests": [[[1, 3, 5], [2, 4, 6]]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(first, second):\n    \"\"\"\n    You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word.\n    \"\"\"\n    return second in set(first) or any(x == second for x in first)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["yello", "ell"]], "plus_fail_tests": [["abcdefg", "cde"]]}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    even, odd = 0, 0\n    for i in range(1, n+1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(num):\n    if num < 1:\n        return \"\"\n\n    res = []\n    for i in range(0, len(str(num)) + 1):\n        div, mod = divmod(num, 5) if i == 0 else divmod(mod, 5)\n        num = div if div > 0 else 1\n        res.append(ROMAN_NUM[mod])\n        num = str(num)\n        if i == 0 and num[-1] == '1':\n            res.append(num)\n        elif i > 0 and num[-1] == '1':\n            res.append(num[0])\n        else:\n            res.append('x')\n\n    return ''.join(res)\nROMAN_NUM = {1: 'i', 5: 'v', 10: 'x', 50: 'l', 100: 'c', 500: 'd', 1000: 'm'}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[19]], "plus_fail_tests": [[111]]}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    for char in s:\n        if char in 'aieou':\n            count += 1\n        elif char == 'y' and s[-1] == 'y':\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Alone"]], "plus_fail_tests": [["JBXFOFH"]]}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    bored = 0\n    for sentence in S.split('.'):\n        sentence = sentence.strip('!?')\n        if sentence.startswith('I'):\n            bored += 1\n    return bored", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["I am very happy today. I love spending time with my friends."]]}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    char_count_lst1 = sum(len(x) for x in lst1)\n    char_count_lst2 = sum(len(x) for x in lst2)\n    if char_count_lst1 == char_count_lst2:\n        return lst1\n    elif char_count_lst1 < char_count_lst2:\n        return lst1\n    elif char_count_lst1 > char_count_lst2:\n        return lst2\n    else:\n        return []", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Returns the area of a triangle given the length of a side and its height.\n    \n    Args:\n    - a (float): Length of a side of the triangle.\n    - h (float): Height of the triangle.\n    \n    Returns:\n    - float: Area of the triangle.\n    \n    Example:\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    # Calculate base of the triangle\n    b = a / 2\n    # Calculate area using Heron's formula\n    area = 0.5 * h * b * math.sqrt(b**2 + h**2)\n    return area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3]], "plus_fail_tests": [[4, 6]]}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "import re\ndef valid_date(date):\n    \"\"\"\n    Validates a given date string and returns True if the date is valid, otherwise False.\n    \"\"\"\n    if not date:\n        return False\n    match = re.match(r\"^(\\d?\\d?)[-/](\\d?\\d?)[-/](\\d{4})$\", date)\n    if not match:\n        return False\n    day, month, year = map(int, match.groups())\n    \n    # Date rules\n    if month == 2 and day > 29:\n        return False\n    elif month in (1, 3, 5, 7, 8, 10, 12) and day > 31:\n        return False\n    elif month in (4, 6, 9, 11) and day > 30:\n        return False\n\n    # Month rules\n    if month < 1 or month > 12:\n        return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["15-01-2012"]], "plus_fail_tests": [["12-31-1999"]]}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    :param text: String to be checked\n    :return: True if string is palindrome, False otherwise\n    \"\"\"\n    # Convert string to lowercase and remove all non-alphanumeric characters\n    text = ''.join(c for c in text if c.isalnum()).lower()\n    return text == text[::-1]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["never odd or even"]]}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def is_palindrome(s: str) -> bool:\n    \"\"\" Returns true if string s is a palindrome, false otherwise \"\"\"\n    return s == s[::-1]\ndef make_palindrome(s: str) -> str:\n    \"\"\" Returns the shortest palindrome string that starts with s \"\"\"\n    if not s:\n        return s\n\n    # Find the position of the longest palindrome suffix in s\n    i = len(s) - 1\n    while i >= 0 and not is_palindrome(s[i:]):\n        i -= 1\n\n    # Extend the string with the reverse of the prefix up to the palindrome suffix\n    j = i\n    while not is_palindrome(s[:j]):\n        j -= 1\n    return make_palindrome(s[:j] + s[i:i+j][::-1] + s[j:])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["x"]], "plus_fail_tests": [["race"]]}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "import hashlib\ndef string_to_md5(text: str) -> str or None:\n    if not text:\n        return None\n    md5 = hashlib.md5()\n    md5.update(text.encode('utf-8'))\n    return md5.hexdigest()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    seen = set()\n    for x in l:\n        if x > 0:\n            if x in seen and l.count(x) > 1:\n                return True\n            seen.add(x)\n        else:\n            if (-x) in seen and l.count(-x) > 1:\n                return True\n            seen.add(-x)\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, -2, 1]]], "plus_fail_tests": [[[0, 1, -1]]]}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    open, close = 0, 0\n    for char in s:\n        if char == '[':\n            open += 1\n        else:\n            close += 1\n        if open > close:\n            return False\n    return open != close", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]]"]], "plus_fail_tests": [["[[]][]"]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1, l2):\n    return sorted(set(l1).intersection(l2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n):\n    prev3, prev2, prev1, curr = 0, 0, 0, 0\n    for _ in range(n):\n        curr = prev3 + prev2 + prev1\n        prev3 = prev2\n        prev2 = prev1\n        prev1 = curr\n    return curr", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[20]]}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "from unittest.mock import patch, call\nimport unittest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    result = []\n    for row in lst:\n        for j, col in enumerate(row):\n            if col == x:\n                result.append((row_index + 1, col_index + 1))\n                break\n        row_index += 1\n    return sorted(result, key=lambda x: (x[0], -x[1]))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1]], "plus_fail_tests": [[[[], [], [], []], 10]]}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    odd = len(array) % 2\n    if odd:\n        array = sorted(array)\n    else:\n        array = sorted(array, reverse=True)\n    return array", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, 3, 0, 1, 5]]], "plus_fail_tests": [[[1, 2, 3, 4]]]}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    dups = {}\n    for x in lst:\n        if x in dups:\n            dups[x] += 1\n        else:\n            dups[x] = 1\n    for x in dups:\n        if dups[x] > 1:\n            return False\n    return all(x <= y for x, y in zip(lst, lst[1:]))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "def concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    result = ''\n    for string in strings:\n        result += string\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    return [abs(x-y) if x != y else 0 for x,y in zip(game, guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "import unittest\ndef remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return text.translate(str.maketrans(\"\", \"\", vowels))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "def by_length(arr):\n    sorted_arr = sorted(arr, key = lambda x: 1 if x <= 9 else x)\n    reversed_sorted_arr = sorted(sorted_arr, reverse = True)\n    result = []\n    for num in reversed_sorted_arr:\n        if 1 <= num <= 9:\n            result.append(NUM_TO_NAME[num])\n    return result if result else []\nNUM_TO_NAME = {\"One\": 1, \"Two\": 2, \"Three\": 3, \"Four\": 4, \"Five\": 5, \"Six\": 6, \"Seven\": 7, \"Eight\": 8, \"Nine\": 9}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 1, 1, 4, 5, 8, 2, 3]]], "plus_fail_tests": [[[9, 8, 7, 6, 5, 4, 3, 2, 1]]]}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    # Helper function to find the max element from the remaining list\n    def max_from_remaining(L):\n        max_so_far = float('-inf')\n        for num in L:\n            if num > max_so_far:\n                max_so_far = num\n        return max_so_far\n\n    # Base case: If the list is empty, return it\n    if not lst:\n        return lst\n\n    # Otherwise, return the minimum value followed by the max of the remaining list\n    return strange_sort_list([min(lst), max_from_remaining(lst[1:])] + lst[2:])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4]]], "plus_fail_tests": [[[-5, 0, 5, 10]]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    arr.sort(key=lambda x: (bin(x).count('1'), x))\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    positive = min(x for x in lst if x > 0)\n    negative = max(x for x in lst if x < 0)\n    return negative, positive", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, 1, 3, 5, 7]]], "plus_fail_tests": [[[1, 1, 1, 1, 1, 1]]]}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\ndef factorize(n: int) -> List[int]:\n    factors = []\n    for divisor in range(2, n):\n        if n % divisor == 0:\n            count = 0\n            while n % divisor == 0:\n                n //= divisor\n                count += 1\n            if count > 0:\n                factors.append(divisor)\n                factors.extend([divisor] * count)\n    if n > 1: \n        factors.append(n)\n    return factors", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[10]]}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(s: str) -> List[int]:\n    result = []\n    for bracket_depth in map(len, s.split()):\n        result.append(max(bracket_depth, result[-1] or 0))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(()()) ((())) () ((())()())"]], "plus_fail_tests": [["((()))"]]}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    # Create a list to store the count of numbers that start or end with 1\n    # for each possible n-digit positive integer\n    counts = [0] * (n * 9)\n    \n    # Count the numbers that start with 1\n    for i in range(1, n + 1):\n        counts[i - 1] += 1\n    \n    # Correct the calculation for numbers that end with 1\n    counts[n * 8 - 1:] = counts[n * 8 - 1:] - counts[:-1]\n    \n    return sum(counts)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[6]]}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    return delimeter if not numbers else numbers + [delimeter] + intersperse(numbers[1:], delimiter)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[], 7]], "plus_fail_tests": [[[1, 2, 3], 0]]}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    odd_collatz = []\n    num = n\n    while num != 1:\n        if num % 2 == 0:\n            num = num // 2\n        else:\n            num = 3 * num + 1\n        odd_collatz.append(num)\n    odd_collatz.sort()\n    return odd_collatz", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[14]], "plus_fail_tests": [[3]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    result = None\n    if arr:\n        signs = [1 if i > 0 else -1 if i < 0 else 0 for i in arr]\n        result = sum([i * j for i, j in zip(arr, signs)])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, -4]]], "plus_fail_tests": [[[-1, 0, 1, 2]]]}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int) -> bool:\n    return all(x < t for x in l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    arr = list(set(arr))        # Remove duplicates\n    return sum(1 for i in range(len(arr)) for j in range(len(arr)-1-i) if arr[i] != arr[j])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 5, 4, 7, 9, 6]]], "plus_fail_tests": [[[1, 2, 3, 4, 5]]]}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n    N = len(grid)\n    dp = [[float('inf')] * N for _ in range(k + 1)]\n    start = [(-1, -1)]\n\n    for i in range(k + 1):\n        for j in range(N):\n            for nei in [(j - 1, -1), (j + 1, -1), (j - 1, 0), (j - 1, 1), (j, 1), (j + 1, 1), (j + 1, 0)]:\n                if 0 <= nei[0] < N and 0 <= nei[1] < N:\n                    if grid[nei[0]][nei[1]] < dp[i][j]:\n                        start = nei\n                        dp[i][j] = grid[nei[0]][nei[1]]\n\n    res = []\n    while k:\n        nei = start\n        while nei != (nei[0], nei[1]):\n            res.append(dp[k][nei[0]])\n            nei = (nei[0] + dp[k][nei[0]], nei[1] + dp[k][nei[0]])\n        res.append(dp[k][nei[0]])\n        k -= 1\n\n    return res[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9]]}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    odd_sqrs = sum(x**2 for x in lst if x % 2 and x >= 0)\n    return 0 if not lst else odd_sqrs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0.1, 0.2, 0.3]]], "plus_fail_tests": [[[1.0, 3.5, -4.6]]]}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Create a function that returns True if the last character of a given string is an alphabetical character and is not part of a word, and False otherwise.\n\n    Parameters:\n    txt (str): The input string to analyze.\n\n    Returns:\n    bool: True if the last character is an alphabetical character and is not part of a word, False otherwise.\n    \"\"\"\n    # Split the string into words using whitespace characters as delimiters\n    words = txt.split()\n    if len(words) == 0:\n        # If the string is empty, return False as there are no characters to analyze\n        return False\n    last_char = words[-1][-1] if len(words[-1]) > 0 else ''\n    # Check if the last character is an alphabetical character\n    is_alphabetical = str.isalpha(last_Char)\n    # Check if the last character is not part of a word (single character or the last character of a word)\n    is_standalone = last_char not in ' '.join(words)\n    return is_alphabetical and is_standalone", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["apple"]], "plus_fail_tests": [["Pumpkin pi e"]]}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\"\"\"\n    l = list(set(l))\n    l.sort()\n    return l", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    if a < 0:\n        a = -a\n    if a > 0:\n        return a ** 3 == int(a ** 3)\n    else:\n        return a == -a ** 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[120]]}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n            return i\n    return 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[27]]}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    letter_grades = {\n        'A+': [4.0, 3.95, 3.9, 3.85, 3.8],\n        'A': [3.7, 3.65, 3.6, 3.55, 3.5],\n        'A-': [3.3, 3.25, 3.2, 3.15, 3.0],\n        'B+': [3.0, 2.95, 2.9, 2.85, 2.8],\n        'B': [2.7, 2.65, 2.6, 2.55, 2.5],\n        'B-': [2.3, 2.25, 2.2, 2.15, 2.0],\n        'C+': [2.0, 1.95, 1.9, 1.85, 1.8],\n        'C': [1.7, 1.65, 1.6, 1.55, 1.5],\n        'C-': [1.3, 1.25, 1.2, 1.15, 1.0],\n        'D+': [1.0, 0.95, 0.9, 0.85, 0.8],\n        'D': [0.7, 0.65, 0.6, 0.55, 0.5],\n        'D-': [0.3, 0.25, 0.2, 0.15, 0],\n        'E': [0.0, 0.0, 0.0, 0.0, 0.0]\n    }\n    return [letter_grades[letter][gpa <= max(letter_grades[letter])] for letter, letter_grades in letter_grades.items() for gpa in grades]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": [[[3.8, 2.5, 3.9, 2.2, 1.0]]]}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets):\n    open_brackets = len(brackets) - brackets.count('(')\n    return open_brackets == close_brackets", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["()"]], "plus_fail_tests": [["()()()()()"]]}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    return number - int(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "from math import sqrt\nimport unittest\ndef is_simple_power(x, n):\n    return type(x) is int and x == n ** int(n**0.5)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[16, 2]], "plus_fail_tests": [[81, 3]]}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list):\n    result = [x + 1 for x in l]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n.\"\"\"\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 2:\n        factors.append(n)\n    return max(factors)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    # Check if n is less than 2, which does not trigger any elements for the counter\n    if n < 2:\n        return []\n    # Creating a counter to count the first n prime numbers less than n and initializing it to 0\n    prime_counter = 0\n    # Iterating through the numbers from 2 to n-1, 2 is the smallest prime number and n-1 is the last potential prime number that can be used (excluding n itself since the task is to return the first n primes)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[2]]}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    delete = [char for char in c]\n    reverse = s[::-1]\n    result = ''.join(char for char in s if char not in delete and char in reverse)\n    return result, result == result[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    strongest, strength = -1, -1\n    for e in extensions:\n        cap = sum(1 for c in e if c.isupper())\n        sm = sum(1 for c in e if c.islower())\n        s = cap - sm\n        if s > strength:\n            strength, strongest = s, e\n    return f'{class_name}.{strongest}'", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Test3", ["oneUPPERcaseletter", "TWoUPPERcaseletTErs", "threeUppercaseletters", "fourlowercaseletters"]]]}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "def sort_numbers(numbers: str) -> str:\n    numbers = [int(char) for char in numbers.split()]\n    numbers.sort()\n    return ' '.join(map(str, numbers))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["three"]], "plus_fail_tests": [["four eight two"]]}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\ndef find_zero(coefficients: list) -> float:\n    \"\"\"\n    Finds a solution x for the equation polynomial = 0.\n    Returns only the first found zero.\n    Works only for lists with even number of coefficients,\n    and assumes the list contains the coefficients of the polynomial in increasing order.\n    \"\"\"\n    if len(coefficients) % 2 == 1:\n        raise ValueError(\"List of coefficients must have an even number of elements.\")\n    if coefficients[0] == 0:\n        raise ValueError(\"Please provide the largest non-zero coefficient.\")\n\n    # Conversion to polynomial equation ax^n + bx^(n-1) + ... + cx + d\n    power = len(coefficients) // 2\n    a = coefficients[len(coefficients) // 2 - 1]\n    b = coefficients[len(coefficients) // 2]\n\n    # Transform the problem to quadratic equation solving\n    # https://en.wikipedia.org/wiki/Quadratic_equation\n    if power > 2:\n        return find_zero(coefficients[:power])\n    elif power == 2:\n        return find_zero_quadratic(a, b)\n    else:\n        raise ValueError(\"polynomial must have at least 2 coefficients\")\ndef find_zero_quadratic(a: float, b: float) -> float:\n    \"\"\"\n    Only works for quadratic polynomials (power = 2)\n    Finds zero of quadratic equation ax^2 + bx + c = 0\n    \"\"\"\n    # Divide quadratic equation mechanically\n    denom = b**2 - 4*a*c\n    var = (b - a*math.sqrt(denom)) / (2*a)\n    if denom < 0:\n        return var\n    else:\n        return var + (b + a*math.sqrt(denom))/(2*a)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": [[[5, 10, -3, 1]]]}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "import unittest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\nfrom itertools import dropwhile\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string \"\"\"\n    return list(reversed(list(dropwhile(lambda x: len(x) > 0, string))));", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["asdfgh"]], "plus_fail_tests": [["Hello there!"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    prev = arr[0]\n    arrange = 0\n    for idx, cur in enumerate(arr[1:], start=1):\n        if cur <= prev:\n            arrange = idx\n            break\n        prev = cur\n    return arrange if arrange != len(arr) and arrange != -1 else -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 4, 5]]], "plus_fail_tests": [[[1]]]}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    p1 = planets.index(planet1)\n    p2 = planets.index(planet2)\n\n    result = []\n    for i in range(p1 + 1, p2 + 1):\n        result.append(planets[i])\n\n    return result if result != [] else None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Jupiter", "Neptune"]], "plus_fail_tests": [["Neptune", "Mercury"]]}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    return ''.join(c.swapcase() if c.isalpha() else c for c in s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1234"]], "plus_fail_tests": [["!!!!1234!!!!"]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    cnt = 0\n    for i in range(0, len(s), 2):\n        if s[i].isupper() and s[i] in 'AEIOU':\n            cnt += 1\n    return cnt", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "import re\ndef hex_key(num):\n    primes = ['2', '3', '5', '7', '11', '13', '17', '19', '23', '29', '31', '37']\n    hex_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n    count = 0\n    num = re.sub('[^A-Fa-f0-9]','',num)\n    if(num==''):\n        return 0\n    for digit in num:\n        if digit in hex_digits:\n            if digit in primes:\n                count += 1\n        elif digit==' ':\n            continue\n        else:\n            return -1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["AB"]], "plus_fail_tests": [["ABCDEF"]]}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(n):\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    factors = set(int(i) for i in range(1, int(n ** 0.5) + 1) if n % i == 0)\n    return not any(x in factors for x in primes)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[99]]}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    return sum(x for x in lst if x % 2 == 1 and lst.index(x) % 2 == 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 3, 3, 3, 3]]], "plus_fail_tests": [[[1, 1, 1, 1, 1, 1]]]}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    lst.sort()\n    if len(lst) < 2:\n        return None\n    else:\n        return lst[-2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5]]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "def f(n):\n    \"\"\" Return a list of size n such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    \"\"\"\n    result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i+1)))\n    return result\ndef factorial(n):\n    \"\"\" Returns the factorial of n which is the multiplication of the numbers from 1 to n (1 * 2 * ... * n).\n    \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return n * factorial(n-1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    swapped = ''.join(c.swapcase() if c.isalpha() else c for c in message)\n    return swapped.translate(str.maketrans(vowels, vowels[2:] + vowels[:2]))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    # If the array is empty, return True\n    if not arr:\n        return True\n\n    # Sort the array\n    arr.sort()\n    \n    # If the sorted array is monotonically decreasing, return True\n    if arr[0] >= arr[1]:\n        return True\n\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": [[[1]]]}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    open_par = '('\n    close_par = ')'\n    if len(lst) != 2:\n        return \"Invalid input\"\n    if lst[0] == lst[1]:\n        return \"No\"\n    if open_par in lst[0] and close_par in lst[1]:\n        return \"Yes\"\n    if open_par in lst[1] and close_par in lst[0]:\n        return \"Yes\"\n    return \"No\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["(()(())", "())())"]]], "plus_fail_tests": [[["(", "()())("]]]}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n):\n    \"\"\"Returns the sum of integers from 1 to n.\"\"\"\n    return sum(range(1, n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    odd_digits = [int(''.join(x for x in str(n) if x.isdigit() and x % 2 != 0)) for n in x]\n    return sorted(list(set(odd_digits)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[15, 33, 1422, 1]]], "plus_fail_tests": [[[257, 369, 781, 409]]]}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    Takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    # Split string into groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range(len(s) // 3)]\n    # Cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["uzfplzjfzcltmdly"]], "plus_fail_tests": [["abcdefghijk"]]}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    stack = []\n    current_group = []\n    result = []\n    \n    for char in paren_string:\n        if char == '(':\n            stack.append(current_group)\n            current_group = []\n        elif char == ')':\n            if not stack:\n                return []  # unbalanced group, returning empty list as convention\n            current_group = stack.pop()\n        else:\n            current_group.append(char)\n    \n    stack.append(current_group)\n    return stack", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(()()) ((())) () ((())()())"]], "plus_fail_tests": [["()"]]}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0, s1):\n    return len(set(s0) & set(s1)) / min(len(s0), len(s1)) > 0.6", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["eabcd", "dddddddabc"]], "plus_fail_tests": [["aaa", "aaa"]]}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\ndef string_xor(a: str, b: str) -> str:\n    result = ''\n    assert a.isalpha() and b.isalpha() and a + b == '10'*len(a) + '1'*len(b)\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["111000", "101010"]], "plus_fail_tests": [["000", "000"]]}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "import unittest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    return s.split()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hi, my name is John"]], "plus_fail_tests": [[",,,,"]]}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def is_prime(number):\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef prime_length(string):\n    string = str(string)\n    # converting string to int to check if it's a prime number\n    if is_prime(int(string)):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello"]], "plus_fail_tests": [["a"]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(lst):\n    seen = set()\n    for a in lst:\n        for b in lst:\n            if a == b:\n                continue\n            for c in lst:\n                if a + b == c and (a, b, c) not in seen and (b, c, a) not in seen and (c, a, b) not in seen:\n                    return True\n        seen.add(a)\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 0]]], "plus_fail_tests": [[[0, 0, 0]]]}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    cur_sum = 0\n    min_sum = nums[0]\n    for n in nums:\n        cur_sum += n\n        if cur_sum < 0:\n            cur_sum = 0\n        min_sum = min(min_sum, cur_sum)\n    return min_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 3, 4, 1, 2, 4]]], "plus_fail_tests": [[[2, 4, -1, 3, 5, -4, 1, -2]]]}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "def triangle_area(a, b, c):\n    s = sum([a, b, c])\n    if abs(s - a) > 1e-6 or abs(s - b) > 1e-6 or abs(s - c) > 1e-6:\n        return -1\n    else:\n        return round(0.5 * (s * (s - a) * (s - b) * (s - c)), 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4, 5]], "plus_fail_tests": [[8, 9, 15]]}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    '''\n    a = x + y == z\n    b = y + z == x\n    c = x + z == y\n    return a or b or c", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[1.5, 5, 3.5]], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x, base):\n    return str(x)\n    # Use string format to convert to base, ensure subtraction doesn't raise error\n    format_str = '{{0:b{}}}'.format(base)\n    return format_str.format(x)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8, 3]], "plus_fail_tests": [[10, 5]]}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    if not dict:\n        return False\n    lowercase_dict = {key: val for key, val in dict.items()}\n    lowercase_keys = lowercase_dict.keys()\n    return all(isinstance(key, str) and key == key.lower() for key in lowercase_keys) or \\\n            all(isinstance(key, str) and key == key.upper() for key in lowercase_keys)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"p": "pineapple", "5": "banana", "a": "apple"}]], "plus_fail_tests": [[{"1": "apple", "2": "banana", "3": "cherry"}]]}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def encode_shift(s: str):\n    \"\"\"\n    Encodes a string by shifting each character by 5 in the alphabet.\n    \n    Args:\n        s (str): Input string to be encoded.\n\n    Returns:\n        str: Encoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded with the encode_shift function.\n    \n    Args:\n        s (str): Input encoded string to be decoded.\n\n    Returns:\n        str: Decoded string.\n    \"\"\"\n    return encode_shift(s, shift=(-5))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["tantywccpjkimslotpzs"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    words = s.split()\n    sorted_alphabets = ''.join(sorted(word, key=str.ascii_lower))\n    return ' '.join(words for word in words if word == sorted_alphabets)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hi"]], "plus_fail_tests": [["12345"]]}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef x_or_y(n, x, y):\n    \"\"\"Return x if n is prime, else return y.\"\"\"\n    if is_prime(n):\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    if len(l) <= 1:\n        return True\n    lo, hi, mid = 0, 1, (len(l) - 1) // 2\n    while hi - lo > 1:\n        if l[mid] <= l[mid - 1] and l[mid] <= l[mid + 1]:\n            return True\n        elif l[mid] >= l[mid - 1] and l[mid] >= l[mid + 1]:\n            return True\n        elif l[mid] < l[mid - 1] and l[mid + 1] > l[mid]:\n            return True\n        elif l[mid] > l[mid - 1] and l[mid + 1] < l[mid]:\n            return True\n        else:\n            mid = (lo + hi) // 2\n            if l[mid] > l[mid - 1]:\n                lo = mid\n            else:\n                hi = mid\n    return l[mid] <= l[mid - 1] or l[mid] >= l[mid + 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 4, 10]]], "plus_fail_tests": [[[1, 1, 1, 2, 1, 1, 1]]]}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    max_even = (x + y) // 2\n    max_even += max_even & 1\n    return max_even if max_even in range(x, y + 1) else -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[33, 12354]], "plus_fail_tests": [[20, 30]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    return (q == q[::-1] and sum(q) <= w)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    pile = [n]\n    while len(pile) < n+1:\n        if n % 2 == 1:\n            n += 2\n        else:\n            n += 1\n        pile.append(n)\n    return pile", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1]]}]}}