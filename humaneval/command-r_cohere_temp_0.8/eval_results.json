{"date": "2024-09-03 21:02", "hash": "fe585eb4df8c88d844eeb463ea4d0302", "eval": {"HumanEval/4": [{"task_id": "HumanEval/4", "solution": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Calculate Mean Absolute Deviation for a list of numbers.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean:\n    MAD = average(|x - x_mean|)\n    Args:\n        numbers (List[float]): A list of numeric values\n\n    Returns:\n        float: Mean Absolute Deviation\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "```python\nfrom typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    Args:\n        values (List[Any]): Mixed list of values\n\n    Returns:\n        List[int]: Filtered list of integers\n    \"\"\"\n    return [x for x in values if isinstance(x, int)]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "```python\ndef multiply(a, b):\n    \"\"\"Returns the product of the unit digits of two integers.\"\"\"\n    return int(str(a)[-1] * str(b)[-1])\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "```python\ndef greatest_common_divisor(a: int, b: int) -> int:\n\"\"\" Return a greatest common divisor of two integers a and b\n\nExample:\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n\"\"\"\n    if b == 0:\n        return a\n    return greatest_common_divisor(b, a % b)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "```python\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p, handles numerics properly.\n\n    Args:\n        n (int): Exponent.\n        p (int): Modulus.\n\n    Returns:\n        int: 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "```python\ndef rounded_avg(n, m):\n    \"\"\"Computes the average of integers from n to m, rounds to nearest integer,\n    converts to binary and returns the result or -1 if n > m.\n    \"\"\"\n    if n > m:\n        return -1\n    avg = sum(range(n, m + 1)) / (m - n + 1)\n    rounded = round(avg)\n    binary = bin(rounded)[2:]\n    return f\"0b{binary}\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "```python\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x to the right by shift positions and return the result as a string.\n    If shift is greater than the number of digits, return the digits in reverse order.\n    \"\"\"\n    digits = str(x)\n    shift = shift % len(digits)  # Normalize shift value\n    return digits[-shift:] + digits[:-shift]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "```python\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Rescales the provided list of numbers such that the smallest number becomes 0 and the largest becomes 1.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n\n    return rescaled\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "```python\ndef encrypt(s):\n    \"\"\"Encrypt a string with a twice-doubled alphabet shift.\n\n    Args:\n        s (str): String to be encrypted.\n\n    Returns:\n        str: Encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            pos = alphabet.find(char)\n            encrypted += alphabet[(pos - shift) % 26]\n        else:\n            encrypted += char\n    return encrypted\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "```python\ndef decimal_to_binary(decimal):\n    \"\"\"Convert a decimal number to binary format and return it as a string with 'db' wrappers.\n\n    Parameters:\n    decimal (int): Number to be converted to binary.\n\n    Returns:\n    str: Converted number in binary format with 'db' wrappers.\n    \"\"\"\n    return \"db\" + bin(decimal)[2:] + \"db\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "```python\nfrom typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in the list.\n    If the list is empty, the sum should be 0 and the product should be 1.\n    \n    Parameters:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        Tuple[int, int]: A tuple containing sum and product of the list elements.\n    \"\"\"\n    sum = 0\n    product = 1\n    for num in numbers:\n        sum += num\n        product *= num\n    return (sum, product)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "```python\ndef count_nums(arr):\n    \"\"\"\n    Count elements with a sum of digits > 0.\n    \"\"\"\n    return sum(1 for num in arr if sum(int(dig) for dig in str(abs(num))) > 0)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "```python\ndef search(lst):\n    '''\n    Returns the greatest integer with frequency >= the integer itself or -1 if none exist.\n    '''\n    if not lst:\n        return -1\n    \n    freq = {}\n    for num in lst:\n        freq[num] = freq.get(num, 0) + 1\n    \n    max_num = -1\n    for num, count in freq.items():\n        if count >= num:\n            max_num = max(max_num, num)\n    \n    return max_num\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "```python\ndef string_sequence(n: int):\n    return \" \".join([str(i) for i in range(n)])\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "```python\ndef find_max(words):\n    \"\"\"Return the word with the maximum number of unique characters.\n    If multiple strings have the maximum number of unique characters,\n    return the lexicographically smallest one.\n    \"\"\"\n    max_len = 0\n    result = \"\"\n    for word in words:\n        if len(set(word)) > max_len:\n            max_len = len(set(word))\n            result = word\n        elif len(set(word)) == max_len and word < result:\n            result = word\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "```python\ndef car_race_collision(n: int):\n    \"\"\"\n    Returns the number of collisions in the car race scenario.\n    \"\"\"\n    return n * (n - 1) // 2\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "```python\ndef is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly four positive even numbers.\n    Returns:\n        bool: True if n can be written as the sum of 4 even numbers, otherwise False.\n    \"\"\"\n    # Check if n is even\n    if n % 2 != 0:\n        return False\n\n    # Iterate over even numbers and check if their sum equals n\n    for i in range(2, n // 2 + 1, 2):\n        if (n - i) % 4 == 0:\n            return True\n\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "```python\ndef sorted_list_sum(lst):\n    result = []\n    for word in lst:\n        if len(word) % 2 == 0:\n            result.append(word)\n    result.sort(key=lambda x: (len(x), x))\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "```python\ndef add(x: int, y: int) -> int:\n    \"\"\"Sums up two integers x and y.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        int: Sum of two integers.\n    \"\"\"\n    return x + y\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "```python\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef intersection(interval1, interval2):\n    \"\"\"Determine if the length of the intersection is a prime number\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Check if the intervals intersect\n    if end1 < start2 or end2 < start1:\n        return \"NO\"\n    \n    # Find the length of the intersection\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n\n    length = intersect_end - intersect_start + 1\n\n    return \"YES\" if is_prime(length) else \"NO\"\n\n# Test cases\nassert intersection((1, 2), (2, 3)) == \"NO\"\nassert intersection((-1, 1), (0, 4)) == \"NO\"\nassert intersection((-3, -1), (-5, 5)) == \"YES\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "```python\ndef closest_integer(value):\n    '''\n    Returns the closest integer to the given value, rounding away from zero\n    if the number is equidistant from two integers.\n    '''\n    num = round(float(value))\n    if abs(num - int(value)) == 0.5:\n        return max(num, int(value))\n    return int(value)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "```python\ndef median(l: list):\n    \"\"\"Compute the median of the list l. \n    The median of an even-length list is the average of the two middle numbers.\n    \n    Args:\n        l (list): A list of numerical values.\n        \n    Returns:\n        float or int: Median of the list.\n    \"\"\"\n    sorted_l = sorted(l)\n    mid = len(sorted_l) // 2\n    if len(sorted_l) % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "```python\ndef correct_bracketing(brackets: str):\n    \"\"\" Check if brackets are correctly matched.\n        brackets is a string of \"<\" and \">\".\n        \n        Args:\n            brackets (str): String with '<' and '>' characters.\n        \n        Returns:\n            bool: True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(\"<\")\n        elif len(stack) > 0 and stack[-1] == \">\":\n            stack.pop()\n        else:\n            return False\n    return not len(stack)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "```python\ndef split_words(txt):\n    '''\n    Splits the input string on different delimiters and returns the resulting words as a list. \n    The priority of the delimiters is as follows: space, comma ','. \n    If no such characters exist in the input, returns the number of lower-case letters with odd order in the alphabet.\n    '''\n    # split on spaces\n    words = txt.split()\n    if words:\n        return words\n    \n    # split on commas\n    words = txt.split(',')\n    if words:\n        return words\n    \n    # count odd ordered lower-case letters\n    return sum(1 for c in txt if c.lower() and ord(c) % 2 == 1)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "```python\ndef histogram(test):\n    \"\"\"Return a dictionary of the most repetitive letters and their counts.\n    \n    Args:\n        test (str): Space separated lowercase letters.\n        \n    Returns:\n        dict: A dictionary containing the most frequent letters and their counts.\n    \"\"\"\n    hist = {}\n    for c in test.split():\n        hist[c] = hist.get(c, 0) + 1\n\n    max_count = max(hist.values())\n    result = {}\n    for letter, count in hist.items():\n        if count == max_count:\n            result[letter] = count\n\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "```python\ndef is_happy(s):\n    \"\"\"Check if the string is happy.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        bool: True if string is happy, False otherwise. Happy string has length at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    return len(s) >= 3 and all(s[i] != s[i + 1] != s[i + 2] for i in range(len(s) - 2))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "```python\ndef derivative(xs):\n    \"\"\" Compute derivative of the polynomial represented by xs.\n    Args:\n        xs (list): Coefficients of the polynomial.\n\n    Returns:\n        list: Coefficients of the derivative polynomial.\n    \"\"\"\n    ds = [0] * len(xs)\n    for i in range(1, len(xs)):\n        ds[i - 1] = i * xs[i]\n\n    return ds\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "```python\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Count the number of distinct characters in a string while ignoring case.\n    \n    Args:\n        string (str): Input string.\n        \n    Returns:\n        int: Number of distinct characters.\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "```python\ndef eat(number, need, remaining):\n    \"\"\"\n    Solves the hungry rabbit problem.\n    Args:\n        number (int): Number of carrots already eaten.\n        need (int): Number of carrots to be eaten.\n        remaining (int): Remaining carrots in stock.\n\n    Returns:\n        List[int]: [Total eaten carrots, Remaining carrots after eating]\n    \"\"\"\n    total_eaten = number + remaining\n    if total_eaten >= need:\n        return [need, remaining - (need - number)]\n    else:\n        return [total_eaten, 0]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "```python\ndef select_words(s, n):\n    \"\"\"Returns a list of words with exactly n consonants.\n\n    Args:\n        s (str): Input string containing words separated by spaces.\n        n (int): Number of consonants to filter by.\n\n    Returns:\n        list: Words with exactly n consonants, in order of appearance.\n\n    Examples:\n        >>> select_words(\"Mary had a little lamb\", 4)\n        ['little']\n\n        >>> select_words(\"Mary had a little lamb\", 3)\n        ['Mary', 'lamb']\n\n        >>> select_words(\"simple white space\", 2)\n        []\n\n        >>> select_words(\"Hello world\", 4)\n        ['world']\n\n        >>> select_words(\"Uncle sam\", 3)\n        ['Uncle']\n    \"\"\"\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonants = 0\n        for char in word:\n            if char.isalpha():\n                consonants += 1\n        if consonants == n:\n            result.append(word)\n    \n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "```python\ndef digits(n):\n\"\"\"Given a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\n\nExample:\n1) digits(1)  == 1\n2) digits(4)  == 0\n3) digits(235) == 15\n\"\"\"\n    prod = 1\n    n = str(n)\n    for digit in n:\n        if int(digit) % 2 == 1:\n            prod *= int(digit)\n        else:\n            return 0\n    return prod\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "```python\nfrom typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result\n\n# Test the function\nassert remove_duplicates([1, 2, 3, 2, 4]) == [1, 3, 4]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "```python\ndef fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n\n    Args:\n        n (int): The position of the desired Fibonacci number.\n\n    Returns:\n        int: Desired Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "```python\nfrom typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parses the music string into a list of integers representing the number of beats.\n\n    Legend:\n    'o' - whole note, 4 beats\n    'o|' - half note, 2 beats\n    '.|' - quarter note, 1 beat\n\n    Parameters:\n    music_string (str): String in the special ASCII format.\n\n    Returns:\n    List[int]: List of integers corresponding to the number of beats.\n    \"\"\"\n    music = music_string.split(' ')\n    beats = []\n    legend = {'o': 4, 'o|': 2, '.|': 1}\n\n    for note in music:\n        beats.append(legend[note])\n\n    return beats\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "```python\ndef solution(lst):\n\"\"\"\nYou are given a list of integers. You need to find the largest prime number and return the sum of its digits.\n\n:param lst:\n:return: integer -- sum of digits of the largest prime number\n\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_prime = float('-inf')\n    sum_of_digits = 0\n\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n        if is_super_prime(max_prime):\n            sum_of_digits = sum(map(int, str(max_prime)))\n\n    return sum_of_digits\n\n\ndef is_super_prime(n):\n    \"\"\"Check if a number is a prime and all its digits are prime as well\"\"\"\n    digits = [int(x) for x in str(n)]\n    for digit in digits:\n        if not is_prime(digit):\n            return False\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "```python\ndef sum_squares(lst):\n    \"\"\"Returns the sum of squared numbers in the list after rounding each element to the upper integer value.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: Sum of squared numbers.\n    \"\"\"\n    return sum(int(x) ** 2 for x in lst)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "```python\ndef add_elements(arr, k):\n    \"\"\"\n    Return the sum of elements with at most two digits from the first 'k' elements of 'arr'.\n\n    Args:\n        arr (list): A non-empty array of integers.\n        k (int): An integer specifying the number of elements to consider from the start of the array.\n\n    Returns:\n        int: The sum of elements with at most two digits.\n    \"\"\"\n    return sum(x for x in arr[:k] if len(str(x)) <= 2)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "```python\ndef order_by_points(nums):\n    \"\"\"\n    Sort the list of integers by the sum of their digits and their original index.\n    \"\"\"\n    nums_with_scores = [(sum(int(d) for d in str(num)), nums.index(num), num) for num in nums]\n    nums_with_scores.sort()\n    return [num for _, _, num in nums_with_scores]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "```python\ndef fix_spaces(text):\n    \"\"\"\n    Replaces all spaces in the input string with underscores, and if there are more than 2 \n    consecutive spaces, replaces them with a dash -.\n    \"\"\"\n    import re\n\n    return re.sub(\" +\", \"-\", text.replace(\" \", \"_\"))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "```python\ndef max_element(l: list):\n    \"\"\"Return the maximum element in the list.\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        int: Maximum element in the list.\n    \"\"\"\n    max_val = float('-inf')\n    for num in l:\n        if num > max_val:\n            max_val = num\n    return max_val\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "```python\ndef sort_even(l: list):\n    \"\"\"Sorts the values of a list l at the even indices only.\n\n    Args:\n        l (list): Target list to be sorted.\n\n    Returns:\n        list: A new list with even indices sorted and odd indices unchanged.\n    \"\"\"\n    l_even = l[::2]\n    sorted_even = sorted(l_even)\n    result = l.copy()\n    result[::2] = sorted_even\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "```python\ndef is_valid_file_name(file_name):\n    \"\"\"Check if the file name is valid.\n\n    Valid file name should meet the following criteria:\n    1. Should not contain more than three digits.\n    2. Should contain exactly one dot '.'.\n    3. The part before the dot should not be empty, and start with a letter of the latin alphabet.\n    4. The part after the dot should be one of ['txt', 'exe', 'dll'].\n\n    Args:\n        file_name (str): Name of the file.\n\n    Returns:\n        str: 'Yes' if the name is valid, otherwise 'No'.\n    \"\"\"\n    # Check 1: More than three digits\n    if len(file_name) > 3 and file_name.isdigit():\n        return 'No'\n\n    # Check 2: Exactly one dot\n    dots = file_name.count('.')\n    if dots != 1:\n        return 'No'\n\n    # Check 3: Before dot validation\n    before_dot = file_name.split('.')[0]\n    if not before_dot or not before_dot.isalpha():\n        return 'No'\n\n    # Check 4: After dot validation\n    after_dot = file_name.split('.')[-1]\n    valid_extensions = {'txt', 'exe', 'dll'}\n    if after_dot not in valid_extensions:\n        return 'No'\n\n    return 'Yes'\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "```python\ndef sort_third(l: list):\n    \"\"\"\n    Sorts the values of the list l that lie at indicies divisible by three, while keeping the other values unchanged.\n\n    Parameters:\n        l (list): The input list.\n\n    Returns:\n        list: A new list with the values at indices divisible by three sorted, and the other values unchanged.\n    \"\"\"\n    l_new = l.copy()\n    third_indices = [i for i in range(len(l_new)) if i % 3 == 0]\n\n    values_at_third_indices = [l_new[idx] for idx in third_indices]\n    sorted_values = sorted(values_at_third_indices)\n\n    for idx, val in enumerate(sorted_values):\n        l_new[third_indices[idx]] = val\n\n    return l_new\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "```python\ndef fib4_efficient(n):\n    \"\"\"Computes the n-th element of the fib4 sequence defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    \"\"\"\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 2\n    prev3, prev2, prev1, prev0 = 0, 0, 2, 0\n    for i in range(3, n+1):\n        curr = prev3 + prev2 + prev1 + prev0\n        prev3, prev2, prev1, prev0 = prev2, prev1, prev0, curr\n    return curr\n\n# Test cases\nassert fib4_efficient(5) == 4\nassert fib4_efficient(6) == 8\nassert fib4_efficient(7) == 14\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "```python\ndef add(lst):\n    \"\"\"Add elements at odd indices that are even.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    return sum(x for index, x in enumerate(lst) if index % 2 == 1 and x % 2 == 0)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "```python\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings only for ones that start with a given prefix.\n    \n    Args:\n        strings (List[str]): The input list of strings.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: A new list containing only the strings that start with the given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "```python\ndef get_closest_vowel(word):\n    \"\"\"Returns the closest vowel between two consonants from the right side of the word.\n    Vowels in the beginning or ending do not count. \n    Returns empty string if no such vowel is found. \n    \"\"\"\n    vowels = \"AEIOUaeiou\"\n    last_consonant = None\n    for c in word[::-1]:\n        if c in vowels:\n            return c\n        else:\n            last_consonant = c\n            \n    return \"\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "```python\ndef flip_case(s):\n    \"\"\"Flips the case of a string, converting uppercase to lowercase and vice versa.\n    \"\"\"\n    return ''.join([char.upper() if char.islower() else char.lower() for char in s])\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "```python\ndef special_factorial(n):\n    \"\"\"Returns the Brazilian factorial of integer n.\n\n    Brazilian factorial is defined as:\n    special_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\n    Parameters:\n        n (int): Positive integer for which to calculate the special factorial.\n\n    Returns:\n        int: The special factorial of the input integer.\n    \"\"\"\n    if n <= 0:\n        return 0\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers are any two numbers closer to each other than\n    the given threshold.\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_nums = sorted(numbers)\n    for i in range(1, len(sorted_nums)):\n        if sorted_nums[i] - sorted_nums[i - 1] < threshold:\n            return True\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "```python\nimport math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    Solves the bucket lowering problem.\n    \n    Args:\n        grid (list): A list of lists representing the wells, where 1 denotes a unit of water.\n        capacity (int): The capacity of the buckets.\n        \n    Returns:\n        int: Number of times the bucket needs to be lowered.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    steps = 0\n    \n    for r in range(rows):\n        col = 0\n        while col < cols:\n            if grid[r][col] == 1:\n                # Find the next column with water, if any\n                next_col = col + 1\n                while next_col < cols and grid[r][next_col] == 0:\n                    next_col += 1\n                \n                num_buckets = math.ceil((grid[r][col] + grid[r][next_col - 1]) / capacity)\n                steps += num_buckets\n                col = next_col\n            else:\n                col += 1\n    \n    return steps\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "```python\ndef do_algebra(operator, operand):\n    \"\"\"\n    Evaluates the algebraic expression built using the operator and operand lists.\n    \"\"\"\n    assert len(operator) == len(operand) - 1\n    assert all(isinstance(num, int) and num >= 0 for num in operand)\n    assert len(operator) >= 1 and len(operand) >= 2\n\n    result = operand[0]\n    for op, num in zip(operator, operand[1:]):\n        result = {\"+\": lambda x: result + x,\n                 \"-\": lambda x: result - x,\n                 \"*\": lambda x: result * x,\n                 \"//\": lambda x: result // x,\n                 \"**\": lambda x: result ** x}[op](num)\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "```python\ndef words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing words from the input sentence whose lengths are prime numbers,\n    preserving the original order.\n    \"\"\"\n    prime_words = []\n    words = sentence.split()\n\n    for word in words:\n        length = len(word)\n        if length > 1 and all(length % i for i in range(2, length)):\n            prime_words.append(word)\n\n    return ' '.join(prime_words)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "```python\ndef tribonacci(n):\n    \"\"\"Returns the first n+1 numbers of the Tribonacci sequence.\"\"\"\n    if n == 0:\n        return []\n    elif n == 1:\n        return [3]\n    elif n == 2:\n        return [3, 2]\n    tri_seq = [3, 2, 1]\n    for _ in range(3, n + 1):\n        next_num = tri_seq[-1] + tri_seq[-2] + tri_seq[-3]\n        tri_seq.append(next_num)\n    return tri_seq\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "```python\ndef sum_squares(lst):\n    \"\"\"\n    Transforms elements of the list based on their index and then sums up the resulting values.\n    Squares the element if the index is a multiple of 3 and cubes it if the index is a multiple of 4 but not a multiple of 3.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of the transformed values in the list.\n    \"\"\"\n    return sum(x**2 if i % 3 == 0 else x**3 if i % 4 == 0 and i % 3 != 0 else x  for i, x in enumerate(lst))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "```python\ndef compare_one(a, b):\n    \"\"\"\n    Compares two variables of type int, float, or str representing real numbers\n    and returns the larger one. Returns None if they're equal.\n    \"\"\"\n    if type(a) == type(b):\n        if isinstance(a, int):\n            return max(a, b)\n        elif isinstance(a, float):\n            return max(a, b)\n        elif a.replace(',', '.').replace('.', ',').lower() == b.lower():\n            return None\n        else:\n            return max(a, b)\n    else:\n        return None\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "```python\ndef prime_fib(n: int):\n    \"\"\"\n    Finds the n-th Fibonacci number that is also a prime.\n    \"\"\"\n    fib_seq = [2, 3]\n    while len(fib_seq) < n + 1:\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n        # Only keep numbers that are prime\n        if is_prime(fib_seq[-1]):\n            fib_seq.pop()\n\n    return fib_seq[n]\n\n\ndef is_prime(num: int) -> bool:\n    \"\"\"Check if num is a prime number.\"\"\"\n    if num == 2:\n        return True\n    if num <= 1 or num % 2 == 0:\n        return False\n\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "```python\ndef count_seven(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "```python\nfrom typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return the two closest numbers \n    in the list and return them in order (smaller number first, larger number second).\n\n    Parameters:\n        numbers (List[float]): A list of at least two float numbers.\n\n    Returns:\n        Tuple[float, float]: Two closest numbers in the list in order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two numbers\")\n\n    min_dist = numbers[1] - numbers[0]  # Initialize min distance between first two elements\n    closest_elements = (numbers[0], numbers[1])  # Initialize closest elements\n\n    for i in range(1, len(numbers) - 1):  # Iterate through the list, skipping first and last elements\n        left_dist = numbers[i] - numbers[i - 1]\n        right_dist = numbers[i + 1] - numbers[i]\n\n        if left_dist < min_dist:\n            min_dist = left_dist\n            closest_elements = (numbers[i - 1], numbers[i])\n\n        if right_dist < min_dist:\n            min_dist = right_dist\n            closest_elements = (numbers[i], numbers[i + 1])\n\n    return closest_elements\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "```python\ndef simplify(x, n):\n    \"\"\"Returns True if x * n evaluates to a whole number, False otherwise.\n    Both x and n are in the form <numerator>/<denominator>.\"\"\"\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    if x_denom * n_num == x_num * n_denom:\n        return True\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "```python\ndef is_palindrome(s):\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return s == s[::-1]\n\ndef make_palindrome(string):\n    if is_palindrome(string):\n        return string\n    \n    # Omit the case of a single character palindrome\n    if len(string) > 1:\n        for i in range(1, len(string)):\n            suffix = string[-i:]\n            if is_palindrome(suffix):\n                prefix = string[:i][::-1]\n                return string + prefix\n               \n    return string + string[::-1]\n\n# Test cases\nassert make_palindrome('') == ''\nassert make_palindrome('cat') == 'catac'\nassert make_palindrome('cata') == 'catac'\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "```python\ndef exchange(lst1, lst2):\n    \"\"\"Determine if it's possible to make lst1 have only even numbers with exchanges.\n\n    Args:\n        lst1 (list): A list of integers.\n        lst2 (list): Another list of integers.\n\n    Returns:\n        str: \"YES\" if possible to exchange for all even in lst1, otherwise \"NO\".\n    \"\"\"\n    odd_in_lst1 = [x for x in lst1 if x % 2 != 0]\n    return \"YES\" if len(odd_in_lst1) <= len(lst2) else \"NO\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "```python\ndef cycpattern_check(word1: str, word2: str) -> bool:\n\"\"\"Returns True if word2 or any of its rotations is a substring of word1\"\"\"\n    if len(word2) > len(word1):\n        return False\n\n    word2 += word2\n    word1_set = set(word1)\n\n    for i in range(len(word2)):\n        if word2[i] in word1_set:\n            if word1_set.issubset(set(word2[i:])):\n                return True\n            if word1_set.issubset(set(word2[i::len(word2)]))):\n                return True\n\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "```python\ndef even_odd_palindrome(n):\n    \"\"\"\n    Count the number of even and odd integer palindromes between 1 and n inclusive.\n\n    Parameters:\n        n (int): Upper limit of the range.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes.\n    \"\"\"\n    even, odd = 0, 0\n\n    # Palindrome with a single digit\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n\n    # Palindrome with two digits\n    for i in range(10, n + 1):\n        temp = i\n        reversed_i = 0\n        while temp > 0:\n            reversed_i = reversed_i * 10 + temp % 10\n            temp //= 10\n        if i == reversed_i:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n\n    return (even, odd)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "```python\ndef int_to_mini_roman(number):\n    \"\"\"\n    Converts a positive integer to a lowercase mini Roman numeral.\n\n    Restrictions: 1 <= num <= 1000\n\n    Parameters:\n    number (int): The positive integer to convert.\n\n    Returns:\n    str: Roman numeral string.\n    \"\"\"\n    rom_val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    rom_sym = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    result = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // rom_val[i]):\n            result += rom_sym[i]\n            number -= rom_val[i]\n        i += 1\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "```python\nFIX = \"\"\"\nAdd more test cases as needed.\n\"\"\"\n\ndef vowels_count(word):\n    \"\"\"\n    Count the number of vowels in a word. 'Y' is considered a vowel only if it's the last letter.\n\n    Parameters:\n        word (str): A string representing a word.\n\n    Returns:\n        int: Number of vowels in the word.\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n\n    if len(word) > 0:\n        if word[-1] == 'y':\n            word = word[:-1]\n\n        for char in word.lower():\n            if char in vowels:\n                count += 1\n\n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "```python\ndef is_bored(S):\n    \"\"\"\n    Count the number of boredoms in a string of words. A boredom is a sentence \n    that starts with \"I\".\n    \"\"\"\n    bored_count = 0\n    sentence_start = True\n\n    for c in S:\n        if c == '.' or c == '?' or c == '!':\n            sentence_start = True\n\n        if sentence_start and c == 'I':\n            bored_count += 1\n            sentence_start = False\n\n        if c == ' ':\n            sentence_start = False\n\n    return bored_count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "```python\ndef generate_integers(a, b):\n    \"\"\"\n    Returns the even digits between a and b (inclusive).\n    Assumes a and b are positive integers.\n\n    Parameters:\n    a (int): The lower bound of the range.\n    b (int): The upper bound of the range.\n\n    Returns:\n    list: Even digits in the range [a, b], sorted in ascending order.\n    \"\"\"\n    even_digits = []\n    for n in range(a, b + 1):\n        num_str = str(n)\n        if int(num_str.even()) and not num_str.startswith('0'):\n            even_digits.append(int(num_str))\n    return sorted(even_digits)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "```python\ndef total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all strings less than the other list.\n    \n    If the lists have the same total number of characters, the first list is returned.\n    '''\n    total_chars_lst1 = sum([len(x) for x in lst1])\n    total_chars_lst2 = sum([len(x) for x in lst2])\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    else:\n        return lst2\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "```python\ndef triangle_area(a, h):\n    \"\"\"Calculate the area of a triangle given side length 'a' and height 'h'.\n\n    Args:\n        a (float): Length of the side.\n        h (float): Height of the triangle.\n\n    Returns:\n        float: Area of the triangle.\n    \"\"\"\n    return 0.5 * a * h\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "```python\nfrom typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of the rolling maximum element found \n    until that moment in the sequence.\n    \n    Args:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        List[int]: A list containing the rolling maximum values\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_values = [numbers[0]]\n    max_val = numbers[0]\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_val:\n            max_val = numbers[i]\n            rolling_max_values.append(max_val)\n        else:\n            rolling_max_values.append(rolling_max_values[-1])\n\n    return rolling_max_values\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "```python\nimport re\n\n\ndef valid_date(date):\n    \"\"\"Validate a date string based on multiple conditions.\n\n    Rules:\n    1. Date string should not be empty.\n    2. Days: 1-31 for Jan, Mar, May, Jul, Aug, Oct, Dec. 1-30 for Apr, Jun, Sep, Nov. 1-29 for Feb.\n    3. Months: 1-12.\n    4. Format: mm-dd-yyyy\n\n    Returns:\n        bool: True if valid, False otherwise.\n    \"\"\"\n    # Check if date string matches the required format\n    if not re.match(r\"^\\d{2}-\\d{2}-\\d{4}$\", date):\n        return False\n\n    month, day, year = map(int, date.split(\"-\"))\n\n    # Validate days and months\n    if (\n        (month in [1, 3, 5, 7, 8, 10, 12] and (day < 1 or day > 31))\n        or (month in [4, 6, 9, 11] and (day < 1 or day > 30))\n        or (month == 2 and (day < 1 or day > 29))\n        or month < 1 or month > 12\n    ):\n        return False\n\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "```python\ndef is_palindrome(text: str):\n    \"\"\"\n    Checks if the given string is a palindrome.\n    This function uses a simple algorithm to compare the first and last characters \n    of the string and iteratively move towards the center.\n    Args:\n        text (str): String to check for palindrome property.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    left, right = 0, len(text) - 1\n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "```python\nimport hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Compute the md5 hash of an input string and return it as a string.\n\n    Args:\n        text (str): Input string to hash.\n\n    Returns:\n        str or None: Md5 hash as a hexadecimal representation string, or None for an empty string input.\n    \"\"\"\n    if not text:\n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode())\n    return md5_hash.hexdigest()\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "```python\ndef pairs_sum_to_zero(nums):\n    \"\"\"\n    Checks if there are two distinct elements in the list that sum up to zero.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        bool: True if such pair exists, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "```python\ndef is_nested(s):\n    '''\n    Checks if a string containing only brackets has a nested bracket sequence.\n    '''\n    stack = []\n    for i in s:\n        if i == '[':\n            stack.append(i)\n        elif i == ']':\n            if len(stack) > 1 and stack[-2] == '[':\n                stack.pop()\n                stack.pop()\n            else:\n                return False\n        else:\n            raise Exception('Invalid input string')\n            \n    return len(stack) > 0\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "```python\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # intersect and sort the lists\n    return sorted(list(set(l1) & set(l2)))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "```python\ndef strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    Args:\n        string (str): String to measure length\n\n    Returns:\n        int: Length of the string\n    \"\"\"\n    return len(string)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "```python\ndef fibfib(n):\n    \"\"\"Computes the n-th element of the fibfib number sequence:\n    fibfib(0) = 0\n    fibfib(1) = 0\n    fibfib(2) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    \"\"\"\n    if n <= 1:\n        return n\n    elif n == 2:\n        return 1\n    # The offset FibFib sequence starts with 0, 0, 1, so the actual index is n - 3.\n    fibs = [0, 0, 1]\n    for i in range(3, n + 1):\n        fibs.append(fibs[i - 1] + fibs[i - 2] + fibs[i - 3])\n    return fibs[n]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "```python\ndef get_row(lst, x):\n    \"\"\"\n    Find integer x in the 2d list and return sorted list of tuples.\n    \"\"\"\n    res = []\n    for i, row in enumerate(lst):\n        idx = row.index(x)\n        res.append((i, idx))\n    res.sort()\n    return res\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "```python\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string, including overlapping cases.\n    \"\"\"\n    if not substring:  # Edge case: empty substring\n        return 0\n    index = 0\n    count = 0\n    while index < len(string):\n        index = string.find(substring, index)\n        if index == -1:\n            break\n        count += 1\n        index += len(substring)\n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "```python\ndef sort_array(array):\n    \"\"\"\n    Sort the array based on the condition specified.\n    Don't change the given array, return a sorted copy instead.\n    \"\"\"\n    sorted_array = array[:]\n    if sum(array[0], array[-1]) % 2 == 1:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n    return sorted_array\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "```python\ndef is_sorted(lst):\n    '''\n    Checks if list of integers is sorted in ascending order and has no duplicates.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if list is sorted and has no duplicates. False otherwise.\n    '''\n    # Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if sorted\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "```python\nfrom typing import List\n\ndef concatenate(strings: List[str]):\n    \"\"\" \n    Concatenate list of strings into a single string\n    and return it.\n    \n    Args:\n        strings (List[str]): Strings to be concatenated.\n\n    Returns:\n        str: Concatenated string.\n    \"\"\"\n    return ''.join(strings)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "```python\ndef compare(game, guess):\n    \"\"\"Return an array showing the difference between the guess and the actual game score.\n    If the guess is correct, the value is 0.\n    \"\"\"\n    result = []\n    for i in range(len(game)):\n        result.append(abs(game[i] - guess[i]))\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "```python\ndef specialFilter(nums):\n\"\"\"Returns the number of elements in the array that are greater than 10 \nand have odd first and last digits.\n\"\"\"\n    count = 0\n    for num in nums:\n        if num > 10:\n            # Convert to string and get first and last digits\n            num_str = str(num)\n            if num_str[0] in '13579' and num_str[-1] in '13579':\n                count += 1\n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "```python\ndef remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input string.\n\n    Args:\n        text (str): Input string.\n\n    Returns:\n        str: String without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([c for c in text if c not in vowels])\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "```python\ndef pluck(arr):\n    \"\"\"\n    Plucks and returns the smallest even value from the tree branch array,\n    or returns [] if no even values or the array is empty.\n    Prioritizes the node with the smallest index in case of ties.\n    \"\"\"\n    even_nodes = [node for node in arr if node % 2 == 0]\n    if not even_nodes or not arr:\n        return []\n\n    smallest_even = min(even_nodes)\n    smallest_index = min([i for i, node in enumerate(arr) if node == smallest_even])\n\n    return [smallest_even, smallest_index]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "```python\ndef convert_numbers_to_words(arr):\n    \"\"\"\n    Sort integers between 1 and 9, reverse, and replace with words.\n    Ignore other numbers. Return empty array for empty input.\n\n    Parameters:\n        arr (list): A list of integers.\n\n    Returns:\n        list: Sorted, reversed, and replaced numbers as strings.\n    \"\"\"\n    numbers = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    sorted_arr = sorted([x for x in arr if 1 <= x <= 9])\n    reversed_arr = sorted_arr[::-1]\n    result = [numbers[x - 1] for x in reversed_arr]\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "```python\ndef strange_sort_list(lst):\n    '''\n    Sort the list in a strange order.\n\n    Args:\n        lst (list): List of integers to be sorted.\n\n    Returns:\n        list: Sorted list in strange order.\n    '''\n    sorted_lst = []\n    min_val = float('inf')\n\n    # Find the minimum value in the list\n    for num in lst:\n        min_val = min(min_val, num)\n\n    # Strange sorting\n    while lst:\n        sorted_lst.append(min_val)\n        max_val = max(lst)\n        lst.remove(max_val)\n        min_val = min_val + 1\n\n    return sorted_lst\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "```python\ndef sort_array(arr):\n    \"\"\"\n    Sort array of non-negative integers based on ones in binary representation.\n    For same number of ones, sort by decimal value.\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "```python\ndef solve(N):\n    \"\"\"Returns the sum of digits of N in binary.\n\n    Args:\n        N (int): A positive integer.\n\n    Returns:\n        str: Sum of digits in binary.\n    \"\"\"\n    sum_of_digits = sum(int(x) for x in str(N))\n    return bin(sum_of_digits)[2:]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "```python\ndef largest_smallest_integers(numbers_list):\n    \"\"\"Returns a tuple with the largest negative integer and the smallest positive integer.\n\n    Args:\n        numbers_list (list): A list of integers with both positive and negative values.\n\n    Returns:\n        tuple: A tuple containing the largest negative integer and the smallest positive integer.\n                Both values are returned as None if the respective integers are not found.\n\n    Examples:\n        >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n        (None, 1)\n\n        >>> largest_smallest_integers([])\n        (None, None)\n\n        >>> largest_smallest_integers([0])\n        (None, None)\n    \"\"\"\n    largest_neg = None\n    smallest_pos = None\n\n    for num in numbers_list:\n        if num < 0:\n            if largest_neg is None or num > largest_neg:\n                largest_neg = num\n        elif num > 0:\n            if smallest_pos is None or num < smallest_pos:\n                smallest_pos = num\n\n    return largest_neg, smallest_pos\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "```python\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order of appearance.\n    Each factor is listed number of times it appears in factorization.\n    Input number should be equal to the product of all the factors.\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n\n    if n > 1:\n        factors.append(n)\n\n    return factors\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "```python\ndef starts_one_ends(n):\n    \"\"\"\n    Count the numbers of n-digit positive integers that start or end with 1.\n    \"\"\"\n    # Starting with 1\n    count = 9**n\n    # Ending with 1\n    count += 10**n - 11**n\n    \n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "```python\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    depth_stack = []\n    max_depth_stack = []\n    tokens = paren_string.split()\n\n    for token in tokens:\n        if token == \"(\":\n            depth = 1\n            depth_stack.append(depth)\n            max_depth_stack.append(depth)\n        elif token == \")\":\n            depth_stack.pop()\n            max_depth = max(max_depth_stack)\n            max_depth_stack.append(max_depth)\n\n    return [max(depth_stack) for depth_stack in max_depth_stack]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "```python\nfrom typing import List\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\" Insert a number 'delimiter' between every two consecutive elements of input list numbers\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimiter)\n        result.append(num)\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "```python\ndef get_odd_collatz(n):\n    \"\"\"\n    Returns a sorted list of odd numbers in the Collatz sequence.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        list: A sorted list containing odd numbers in the Collatz sequence.\n    \"\"\"\n    sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 != 0:\n            sequence.append(n)\n    sequence.sort()\n    return sequence\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "```python\ndef prod_signs(arr):\n    \"\"\"\n    Calculate the sum of magnitudes multiplied by the product of signs.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int or float or None: Sum of magnitudes with the product of signs, or None for an empty array.\n    \"\"\"\n    signs = [1 if a != 0 else 0 for a in arr]\n    magnitudes = [abs(a) for a in arr]\n\n    if not signs:  # Empty array\n        return None\n\n    prod = 1\n    for s in signs:\n        prod *= s\n\n    return prod * sum(magnitudes)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "```python\ndef below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below the threshold t.\n    \"\"\"\n    for num in l:\n        if num >= t:\n            return False\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "```python\ndef smallest_change(arr):\n    \"\"\"\n    Finds the minimum number of elements to change to make the array palindromic.\n\n    Args:\n        arr (list): An array of integers.\n\n    Returns:\n        int: The minimum number of elements that need to be changed.\n    \"\"\"\n    # O(n) time, O(n) space, where n is the length of arr\n    n = len(arr)\n    left, right = 0, n - 1\n    changes = 0\n\n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n            left += 1\n            right -= 1\n        else:\n            left += 1\n            right -= 1\n\n    return changes\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "```python\ndef minPath(grid, k):\n    \"\"\"\n    Finds the minimum path of length k in the grid.\n\n    Parameters:\n        - grid (list of lists): A grid with N rows and N columns.\n        - k (int): The length of the path.\n\n    Returns:\n        - list: An ordered list of the values on the cells \n            that the minimum path goes through.\n    \"\"\"\n    N = len(grid)\n    path = []\n    visited = set()\n\n    def dfs(x, y, current_path):\n        if len(current_path) == k:\n            path.extend(current_path)\n            return\n\n        current_path.append(grid[x][y])\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                dfs(nx, ny, current_path[:])\n                visited.remove((nx, ny))\n        current_path.pop()\n\n    for x in range(N):\n        for y in range(N):\n            if (x, y) not in visited:\n                visited.add((x, y))\n                dfs(x, y, [grid[x][y]])\n                visited.remove((x, y))\n\n    return path\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "```python\ndef double_the_difference(lst):\n    '''\n    Calculates the sum of squares of odd integers in the list, ignoring negative numbers and non-integers.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of squares of odd numbers or 0 if the list is empty.\n    '''\n    return sum(x**2 for x in lst if x > 0 and isinstance(x, int) and x % 2 != 0) or 0\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "```python\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Checks if the last character of a string is an alphabetical \n    character and is not part of a word.\n\n    Parameters:\n    txt (str): Input string.\n\n    Returns:\n    bool: True if the last char is an alphabetical character \n    and is not part of a word, False otherwise.\n    '''\n    words = txt.split()\n    last_char = txt[-1]\n\n    if len(words) == 0:\n        return False\n\n    if len(words) == 1:\n        return txt[-1].isalpha()\n\n    return words[-1][-1].isalpha()\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "```python\ndef maximum(arr, k):\n    \"\"\"\n    Returns the maximum k numbers from the given array.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): Number of maximum elements to return.\n\n    Returns:\n        list: A sorted list containing the maximum k numbers from the input array.\n    \"\"\"\n    max_k_nums = sorted(arr)[-k:]\n    return max_k_nums\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "```python\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))\n    \n# Tests\nassert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "```python\ndef iscube(a):\n    '''\n    Checks if integer a is a cube of some integer number.\n    '''\n    # Cube roots are always positive, so we can ignore the sign\n    a = abs(a) \n    root = a ** (1/3)\n    return root.is_integer()\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "```python\ndef largest_divisor(n: int) -> int:\n\"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n\nArgs:\n    n (int): Number to find the largest divisor for\n\nReturns:\n    int: Largest number that divides n evenly\n\"\"\"\n    # Initialize the largest divisor to 1\n    max_divisor = 1\n\n    # Iterate through potential divisors\n    for i in range(2, n):\n        # Check if n is divisible by i\n        if n % i == 0:\n            # Update the max divisor if a larger divisor is found\n            max_divisor = i\n\n    return max_divisor\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "```python\ndef correct_bracketing(brackets: str):\n    \"\"\" Returns True if every opening bracket has a corresponding closing bracket.\n    Args:\n        brackets (str): String containing only '(' and ')' characters.\n\n    Returns:\n        bool: True if correctly bracketted, False otherwise.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif not stack or stack[-1] != '(' :\n            return False\n        else:\n            stack.pop()\n    return not stack\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "```python\ndef numerical_letter_grade(grades):\n    letter_grades = {\n        4.0: 'A+',\n        'A': 3.7,\n        'A-': 3.3,\n        'B+': 3.0,\n        'B': 2.7,\n        'B-': 2.3,\n        'C+': 2.0,\n        'C': 1.7,\n        'C-': 1.3,\n        'D+': 1.0,\n        'D': 0.7,\n        'D-': 0.0,\n        'E': 0.0\n    }\n    result = []\n    for grade in grades:\n        for l, h in letter_grades.items():\n            if grade >= h:\n                result.append(l)\n                break\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "```python\ndef truncate_number(number: float) -> float:\n    \"\"\" Return the decimal part of a positive floating point number.\n\n    Args:\n        number (float): A positive floating point number to truncate.\n\n    Returns:\n        float: The decimal part of the input.\n    \"\"\"\n    return number - // int(number)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "```python\ndef is_simple_power(x, n):\n    \"\"\"Returns True if x is a simple power of n, False otherwise.\n    A simple power has integer exponent.\n    \"\"\"\n    return x == n**int(math.log(x, n))\n\n# Additional example tests:\nassert is_simple_power(1, 4) == True\nassert is_simple_power(2, 2) == True\nassert is_simple_power(8, 2) == True\nassert is_simple_power(3, 2) == False\nassert is_simple_power(3, 3) == False\nassert is_simple_power(16, 4) == True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "```python\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n > 1 which is not a prime.\"\"\"\n    if n % 2 == 0:\n        return 2\n    # Use the fact that all odd numbers greater than 2 can be written as 6k \u00b1 1\n    for k in range(1, (n - 1) // 3 + 1):\n        if n % (6 * k) == 1:\n            return 6 * k - 1\n        elif n % (6 * k) == 5:\n            return 6 * k + 1\n    return None\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "```python\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "```python\ndef reverse_delete(s, c):\n    # Delete characters in s that are in c\n    s = ''.join([x for x in s if x not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = s == s[::-1]\n    \n    return s, is_palindrome\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "```python\ndef count_up_to(n):\n    primes = []\n    for num in range(2, n + 1):\n        # simple optimization, skip middle five numbers,\n        # since they are unlikely to be prime\n        if num % 2 == 0 or num % 5 == 0:\n            continue\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n        if is_prime:\n            primes.append(num)\n    return primes\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "```python\ndef Strongest_Extension(class_name, extensions):\n    def calc_strength(name):\n        return sum(1 for char in name if char.isupper()) - sum(1 for char in name if char.islower())\n\n    strongest = max(extensions, key=calc_strength)\n    return f\"{class_name}.{strongest}\"\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "```python\nfrom typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    \"\"\"\n    choices = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    numbers = numbers.split()\n    numbers.sort(key=choices.index)\n    return ' '.join(numbers)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "```python\nimport math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + ... + xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\"\n    Finds a zero point of a polynomial with given coefficients xs.\n    The function returns one zero point, even if there are multiple ones.\n    It's guaranteed to work if xs has even number of elements and\n    the highest non-zero coefficient.\n    \"\"\"\n    # Ensure the highest non-zero coefficient is at the end\n    non_zero_idx = next((i for i, x in enumerate(xs) if x != 0), len(xs))\n    xs = xs[non_zero_idx:] + xs[:non_zero_idx]\n\n    # Use the fact that polynomial has x=0 as a root\n    # and use backward substitution\n    x_n = 1 / math.pow(xs[-1], -1)\n    for i in range(len(xs) - 1, 0, -1):\n        x_i = x_n * (-xs[i] / xs[i + 1])\n        x_n = x_i + math.pow(x_i, len(xs) - i - 1)\n    return x_i\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "```python\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n\"\"\" Out of the provided list of strings, this function returns the longest one. If multiple\nstrings are of the same length, the first one is returned. If the list is empty, the function\nreturns None.\n\nParameter:\n    strings (List[str]): A list of strings.\n\nReturns:\n    Optional[str]: The longest string in the list or None if the list is empty.\n\"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "```python\ndef can_arrange(arr):\n    \"\"\"Returns the largest index of an element which is not greater than or\n    equal to the previous element in the given array. If no such element is\n    found, return -1.\n\n    Args:\n        arr (list): A list of integers with no duplicates.\n\n    Returns:\n        int: Largest index of an element fulfilling the condition or -1.\n    \"\"\"\n    max_idx = -1\n    for idx in range(len(arr) - 1):\n        if arr[idx] >= arr[idx + 1]:\n            max_idx = idx\n    return max_idx\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "```python\nfrom typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return a list of all prefixes of the input string from shortest to longest.\n    \"\"\"\n    prefixes = []\n    prefix = \"\"\n    for char in string:\n        prefix += char\n        prefixes.append(prefix)\n    return prefixes[::-1]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "```python\ndef bf(planet1, planet2):\n    '''\n    Returns a tuple containing planets with orbits between planet1 and planet2.\n    '''\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet1_index = planets.index(planet1)\n    planet2_index = planets.index(planet2)\n    \n    if planet1_index or planet2_index == -1:\n        return ()\n\n    left = planet1_index\n    right = planet2_index\n\n    result = []\n    for planet in planets[left:right+1]:\n        result.append(planet)\n\n    return tuple(sorted(result, key=planets.index))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "```python\ndef count_upper(s):\n    \"\"\"\n    Count uppercase vowels in even indices.\n    \n    Args:\n        s (str): Input string.\n        \n    Returns:\n        int: Number of uppercase vowels in even indices.\n    \"\"\"\n    vowels = \"AEIOUaeiou\"\n    count = 0\n    for idx in range(len(s)):\n        if s[idx] in vowels and idx % 2 == 0:\n            count += 1\n    return count\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "```python\ndef solve(s):\n    \"\"\"\n    Changes case of letters and reverses non-letter characters.\n    Reverses the string if no letters are present.\n    \n    Args:\n        s (str): Input string.\n        \n    Returns:\n        str: Processed string.\n    \"\"\"\n    letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    result = ''\n    rev = False\n\n    for char in s:\n        if char in letters:\n            result += letters[(letters.lower().index(char.lower()) + 15) % 52]\n        else:\n            rev = not rev\n            result += char\n\n    return result[::-1] if rev else result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "```python\ndef is_prime(num):\n    \"\"\"Check if number num is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** (1/2)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef hex_key(hex_str):\n    \"\"\"Count prime hexadecimal digits in hex_str.\"\"\"\n    primes = 0\n    for digit in hex_str:\n        if digit in '2357BD':\n            primes += 1\n    return primes\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Detect if account balance falls below zero at any point.\n    Returns True if it does, False otherwise.\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "```python\ndef is_multiply_prime(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Multiply Prime\n    if n < 100:\n        count = 0\n        for i in range(2, int(n ** (1/2)) + 1):\n            if is_prime(i) and is_prime(n // i):\n                count += 1\n        return count == 2\n    else:\n        return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "```python\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [i for i in l if i > 0]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "```python\ndef solution(lst):\n    \"\"\"Returns the sum of odd integers in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "```python\ndef f(n):\n    \"\"\" Returns a list of size n with the element at index i being the factorial of i if i is even,\n    or the sum of numbers from 1 to i if i is odd.\n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\n\ndef factorial(n):\n    \"\"\"Returns the factorial of n.\"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "```python\ndef next_smallest(numbers):\n    \"\"\"\n    Returns the second smallest element or None if not found.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    numbers = sorted(numbers)\n    return numbers[1] if numbers[0] != numbers[1] else None\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "```python\ndef encode(message):\n    \"\"\"\n    Encodes the message by swapping cases of all letters and replacing vowels \n    with the letter that appears two places ahead in the alphabet.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(\n        char.upper() if char.islower() else char.lower() \n        for char in message \n        if char in vowels \n        for i in range(2)\n        ).replace('A', 'M').replace('E', 'H').replace('I', 'O')\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "```python\ndef fruit_distribution(s, n):\n    \"\"\"\n    Distributes fruits from a basket described in a string into apples, oranges, and mangoes.\n\n    Parameters:\n    s (str): Description of the number of apples and oranges in the format \"X apples and Y oranges\".\n    n: Total number of fruits in the basket.\n\n    Returns:\n    int: Number of mangoes in the basket.\n    \"\"\"\n    # Split the sentence to extract numbers.\n    words = s.split() \n    apples = int(words[0].replace(\"apples\", \"\"))\n    oranges = int(words[3].replace(\"oranges\", \"\"))\n\n    # Calculate the number of mangoes.\n    return n - apples - oranges\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "```python\ndef move_one_ball(arr):\n    \"\"\"\n    Determine if the array can be sorted by right shifts.\n\n    Args:\n        arr (list): A list of integers with unique elements.\n\n    Returns:\n        bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    if not arr:  # Edge case: Empty array\n        return True\n    \n    max_val = max(arr)\n    idx = arr.index(max_val)\n\n    # Check if the max value can be moved to the front\n    for i in range(idx, -1, -1):\n        if arr[i] < max_val:\n            return False\n    \n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "```python\ndef sum_to_n(n: int):\n    \"\"\"This function calculates the sum of numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the sum range.\n        \n    Returns:\n        int: The sum of numbers from 1 to n.\n    \"\"\"\n    return sum(range(1, n + 1))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "```python\ndef match_parens(lst):\n    '''\n    Checks if two strings consisting of only parentheses can be concatenated \n    to form a balanced string.\n    '''\n    open_count = lst[0].count('(')\n    close_count = lst[1].count(')')\n\n    if open_count == close_count:\n        return 'Yes'\n    else:\n        return 'No'\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "```python\ndef unique_digits(x):\n    \"\"\"Returns a sorted list of elements with unique digits from the given list of positives.\n\n    Args:\n        x (list): A list of positive integers.\n\n    Returns:\n        list: A sorted list of integers with unique digits.\n    \"\"\"\n    result = []\n    for num in x:\n        has_even_digit = any(int(char) % 2 == 0 for char in str(num))\n        if not has_even_digit:\n            result.append(num)\n    result.sort()\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "```python\ndef make_a_pile(n):\n    \"\"\"\n    Construct a pile of stones with n levels following the problem statement.\n    \"\"\"\n    result = []\n    if n % 2 == 1:  # Odd number of stones in the first level\n        current_stones = n\n        while current_stones != 1:\n            result.append(current_stones)\n            current_stones = (current_stones + 1) // 2  # Move to next odd number\n    else:  # Even number of stones in the first level\n        current_stones = n\n        while current_stones > 1:\n            result.append(current_stones)\n            current_stones //= 2  # Move to next even number\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "```python\ndef decode_cyclic(encoded_str: str):\n    \"\"\"\n    Decodes a string encoded with the encode_cyclic function.\n    \"\"\"\n    # Split the encoded string into groups of 3 characters.\n    groups = [encoded_str[i:i + 3] for i in range(0, len(encoded_str), 3)]\n    \n    # Iterate over each group and move the first character to the end.\n    decoded_groups = [''.join([group[1], group[2], group[0]]) for group in groups]\n    \n    # Join the decoded groups to form the original string.\n    return ''.join(decoded_groups)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "```python\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings and return only the ones containing the given substring.\n\n    Args:\n        strings (List[str]): The input list of strings.\n        substring (str): Substring to filter by. Must not be empty.\n\n    Returns:\n        List[str]: Filtered list of strings.\n    \"\"\"\n    if not substring:\n        raise ValueError(\"Substring argument must not be empty\")\n\n    return [s for s in strings if substring in s]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate balanced parentheses groups in the input string and return them as a list.\n\n    Args:\n        paren_string (str): Input string containing nested parentheses groups.\n\n    Returns:\n        List[str]: A list of strings representing separate groups.\n    \"\"\"\n    result = []\n    brace_stack = []\n    for char in paren_string:\n        if char == '(':\n            brace_stack.append('(')\n        elif char == ')':\n            if brace_stack:\n                brace_stack.pop()\n                group = ''.join(brace_stack)\n                result.append(group)\n            else:\n                brace_stack.append(')')\n\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "```python\ndef odd_count(lst):\n    return [f\"the number of odd elements {len([x for x in s if x % 2 != 0])}n the str{len([x for x in s if x % 2 != 0])}ng {i} of the {len([x for x in s if x % 2 != 0])}nput.\" \n            for i, s in enumerate(lst)]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "```python\ndef is_prime(n):\n    \"\"\"Returns true if n is a prime number, and false otherwise.\n    Prime numbers are positive integers greater than 1 that have no positive divisors other than 1 and themselves.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "```python\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return sorted(s0) == sorted(s1)\n\n# Tests\nassert same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\nassert same_chars('abcd', 'dddddddabc') == True\nassert same_chars('dddddddabc', 'abcd') == True\nassert same_chars('eabcd', 'dddddddabc') == False\nassert same_chars('abcd', 'dddddddabce') == False\nassert same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "```python\nfrom typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform binary XOR on the two input strings consisting only of 1s and 0s and return the result as a string.\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have equal length.\")\n\n    result = \"\"\n    for i in range(len(a)):\n        result += str((int(a[i]) ^ int(b[i])))\n\n    return result\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "```python\ndef even_odd_count(num):\n    \"\"\"Return a tuple with counts of even and odd digits in 'num' respectively.\n\n    Args:\n        num (int): Target number.\n\n    Returns:\n        tuple: Even and odd digit counts.\n    \"\"\"\n    even, odd = 0, 0\n    num = abs(num)  # Ensure positive number\n    digits = str(num)\n    for digit in digits:\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return even, odd\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "```python\ndef words_string(s):\n    \"\"\"\n    Splits a string of words separated by commas or spaces into an array of words.\n\n    Args:\n        s (str): String of words separated by commas or spaces.\n\n    Returns:\n        list: Words as a list of strings.\n    \"\"\"\n    return s.split()[::2] + s.split(',')[1::2]\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "```python\ndef prime_length(string):\n    \"\"\"Returns True if the length of the string is a prime number, False otherwise.\"\"\"\n    length = len(string)\n    for num in range(2, length):\n        if length % num == 0:\n            return False\n    return True\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "```python\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Checks if there are three distinct elements in the list that sum up to zero.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        bool: True if such elements exist, False otherwise.\n    \"\"\"\n    # Create a dictionary with element counts\n    count_dict = {}\n    for num in l:\n        count_dict[num] = count_dict.get(num, 0) + 1\n\n    # Check for three distinct elements with zero sum\n    for num1 in count_dict:\n        if count_dict[num1] > 1:\n            for num2 in count_dict:\n                if num1 != num2 and count_dict[num2] > 0:\n                    opposite = -num1 - num2\n                    if opposite in count_dict and count_dict[opposite] > 0:\n                        return True\n\n    return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "```python\ndef digitSum(s):\n    \"\"\"Returns the sum of ASCII codes of uppercase digits in the input string.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        int: Sum of ASCII codes of uppercase characters.\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "```python\ndef minSubArraySum(nums):\n    \"\"\"\n    Finds the minimum sum of any non-empty subarray.\n    Args:\n        nums (list): The input list of integers.\n    Returns:\n        int: Minimum sum of any subarray.\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list\n    min_sum = float('inf')\n    start = 0\n    for end in range(len(nums)):\n        min_sum = min(min_sum, nums[end])\n        # Move the start index until we find a smaller number than min_sum\n        while nums[start] > min_sum:\n            min_sum = min(min_sum, nums[start])\n            start += 1\n        # Now min_sum is the minimum sum of the current subarray\n        # ending at end and starting at start\n    return min_sum\n\n# Example usage\nassert minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\nassert minSubArraySum([-1, -2, -3]) == -6\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "```python\ndef right_angle_triangle(a, b, c):\n    '''\n    Checks if the three sides form a right angle triangle.\n    '''\n    return a**2 == b**2 + c**2 or b**2 == a**2 + c**2 or c**2 == a**2 + b**2\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "```python\ndef triangle_area(a, b, c):\n    '''\n    Calculates the area of a triangle given its three sides. \n    Returns the area rounded to 2 decimal places if the sides form a valid triangle, \n    else returns -1.\n    '''\n    # Check if the triangle is valid\n    if a + b > c and a + c > b and b + c > a:\n        area = (a + b + c) / 4\n        return round(area, 2)\n    else:\n        return -1\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "```python\ndef any_int(x, y, z):\n    '''\n    Checks if one number is the sum of the other two and all numbers are integers.\n    \n    Parameters:\n    x (int): A number.\n    y (int): A number.\n    z (int): A number.\n    \n    Returns:\n    bool: True if one number is the sum of the other two, and all numbers are integers, otherwise False.\n    '''\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    \n    s = x + y\n    return s == z or s == x or s == y\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "```python\ndef change_base(x: int, base: int):\n    \"\"\"Convert numbers to different bases.\n    Args:\n        x (int): number to convert\n        base (int): base to convert x to, base < 10\n    Returns:\n        str: x converted to the specified base\n    \"\"\"\n    x = bin(x)[2:]  # Get the binary representation of x\n    return ''.join([change_base_helper(int(d)) for d in x[::-1]])\n\ndef change_base_helper(x: int):\n    return str(x % base) if x < base else chr(x % base + 48)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "```python\ndef check_dict_case(d):\n    \"\"\"\n    Checks if all keys in the dictionary are in lower or upper case and returns False \n    if the dictionary is empty.\n    \"\"\"\n    if not d:\n        return False\n    lower_case_check = all(isinstance(key, str) and key.islower() for key in d)\n    upper_case_check = all(isinstance(key, str) and key.isupper() for key in d)\n    return lower_case_check or upper_case_check\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "```python\ndef decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded with encode_shift function.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "```python\ndef anti_shuffle(s):\n    \"\"\"\n    Reorders the words in the input string such that the words are rearranged \n    based on their ASCII values while maintaining their relative order.\n\n    Parameters:\n        s (str): Input string with multiple words.\n\n    Returns:\n        str: Reordered string with words sorted by ASCII values.\n    \"\"\"\n    words = s.split()\n    sorted_words = [sorted(word, key=lambda x: x.lower()) for word in words]\n    return ' '.join(sorted_words)\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "```python\ndef is_prime(n):\n    \"\"\"Check if input number n is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef x_or_y(n, x, y):\n    \"\"\"Return x if n is prime, else return y.\"\"\"\n    return x if is_prime(n) else y\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "```python\ndef monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    Args:\n        l (list): Target list to check for monotonic properties.\n\n    Returns:\n        bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n    # Check for special case of empty list\n    if len(l) == 0:\n        return False\n\n    # Check for increasing monotonicity\n    if l[0] <= l[1]:\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n\n    # Check for decreasing monotonicity\n    return all(l[i] >= l[i - 1] for i in range(1, len(l)))\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "```python\ndef choose_num(x, y):\n    \"\"\"Returns the largest even integer in the range [x, y] or -1 if none exist.\n\n    Args:\n        x (int): Lower bound of the range.\n        y (int): Upper bound of the range. Must be greater than x.\n\n    Returns:\n        int: Largest even integer in the range [x, y] or -1.\n    \"\"\"\n    if y < x:\n        raise ValueError(\"Invalid input range\")\n    even_numbers = [num for num in range(x, y + 1) if num % 2 == 0]\n    if even_numbers:\n        return max(even_numbers)\n    else:\n        return -1\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "```python\ndef get_max_triples(n):\n    def count_triples(num):\n        # Count the number of triples for the given num\n        count = 0\n        for i in range(1, num // 3 + 1):\n            for j in range(2 * i, num // 2 + 1, i):\n                k = num - i - j\n                count += 1\n        return count\n\n    # Use the count_triples function to calculate the answer\n    return count_triples(n * (n + 1) // 2 - 1)  # Formula for sum of first n natural numbers\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "```python\ndef will_it_fly(q, w):\n    '''\n    Checks if an object will fly based on balance and weight.\n\n    Parameters:\n    q (list): A list representing the object's weight distribution.\n    w (int): The maximum possible weight.\n\n    Returns:\n    bool: True if the object will fly, False otherwise.\n    '''\n    # Check if the list is palindromic\n    if q == q[::-1]:\n        # Check if the sum of the elements is less than or equal to the maximum weight\n        return sum(q) <= w\n    else:\n        return False\n```", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}]}}