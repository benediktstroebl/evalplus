Here is a Python script with a self-contained function that solves the problem:
```python
from typing import List, Tuple

def rolling_max(numbers: List[int], rolling_window: int) -> List[int]:
    return [max(numbers[i:i+rolling_window]) for i in range(len(numbers) - rolling_window + 1)]
```

The `rolling_max` function takes in a list of integers `numbers` and an integer `rolling_window` as input. It returns a list of integers, where each integer corresponds to the maximum value of the `rolling_window` size sublist on the original list, from each moment of the sequence. The list is generated by iterating through the list with the offset `rolling_window - 1` and using the `max` function to find the maximum value in the rolling window.

Here is an example usage of the function:
```python
print(rolling_max([1, 2, 3, 2, 3, 4, 2], 3))
```
This will output:
```
[1, 2, 3, 3, 3, 4, 4]
```
The rolling maximum for a window of size 3 for the list [1, 2, 3, 2, 3, 4, 2] is [1, 2, 3, 3, 3, 4, 4]. At each step of the sequence, it takes the current element and the two preceding ones, and the rolling maximum is the maximum of this sublist. 

This list is generated by taking the first element and computing the maximum of the first three elements (1, 2, 3) giving 1, then taking the second element and computing the maximum of the next three elements (2, 2, 3) giving 2, and so on until the end of the list. 

This function is self-contained, meaning that it does not rely on any external variables or functions. It can be run as a standalone script, and it will output the rolling maximum value for the given input.