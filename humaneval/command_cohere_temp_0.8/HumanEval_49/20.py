Here's a Python script with a self-contained function that solves the problem:
```python
def modp(n, p):
    return (1 << n) % p

# Tests
assert modp(3, 5) == 3
assert modp(1101, 101) == 2
assert modp(0, 101) == 1
assert modp(3, 11) == 8
assert modp(100, 101) == 1
```

The function `modp` takes two arguments: `n` which is an integer and `p` which is also an integer. It returns the remainder when `2` raised to the power of `n` is divided by `p`. 

The tests are designed to verify the function's behavior against a range of inputs and ensure that it matches the problem statement.  The `assert` statements will trigger an error if the tests fail, indicating that the function does not produce the expected results.  This is a common practice in test-driven development to validate the correctness of code and ensure that it behaves as expected.  This approach helps to catch errors and ensure that the code remains functional as it is updated and modified in the future.  Feel free to add more tests to this script as needed to cover a broader range of scenarios and validate the robustness of your code.  This includes edge cases and boundary conditions to ensure the robustness of your code.  These are often key vectors for error and unexpected behavior, and ensuring that the code handles them gracefully is a good practice.  Finally, this code snippet can be executed directly in the Python interpreter to execute the function and see the test results.  This can be a quick way to verify the code briefly or demonstrate its behavior.  This is a common practice in exploratory programming and debugging, where you can interactively test and observe the behavior of code.  This can help you better understand the underlying processes and build confidence in its operation.  If desired, the code can also be executed in the context of a larger application or test suite, depending on the specific use case and development process.  Nevertheless, direct execution in the interpreter can be a convenient way to validate the code quickly and independently.  This makes it easier to isolate and debug potential problems, which is especially useful when working on complex projects where errors may be difficult to identify.  Finally, this approach promotes iterative development, as it allows for quick iterations and instantaneous feedback on code changes.  This can help you streamline your development workflow and produce higher-quality code with less effort. In summary, adding tests and executing the code directly in the Python interpreter are two valuable practices that promote robust and maintainable code, helping to ensure that your code remains functional and reliable over time.  This approach leads to more robust and maintainable code in the long term, reducing the risk of bugs and security issues.  This makes it easier to adapt to changing requirements and new challenges over the lifecycle of your projects.  These practices are also applicable to a wide range of Python projects and can be leveraged across different domains and problem types.  This can help you streamline your development skills and build more complex and powerful applications with less risk and effort.  Feel free to adapt this code snippet and development approach to your specific needs and preferences, which can vary based on the project size, complexity, and team dynamics.  This will allow you to maximize the benefits of testing and iterative development while making your Python code more robust and reliable.  Finally, the willingness to iterate and improve code over time is an essential mindset in software development, as it encourages continuous improvement and helps to create better projects.  By incorporating these practices into your development workflow, you can become a more effective and efficient programmer, increasing your impact and