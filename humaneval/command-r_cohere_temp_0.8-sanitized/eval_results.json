{"date": "2024-09-03 21:07", "hash": "fe585eb4df8c88d844eeb463ea4d0302", "eval": {"HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    Args:\n        values (List[Any]): Mixed list of values\n\n    Returns:\n        List[int]: Filtered list of integers\n    \"\"\"\n    return [x for x in values if isinstance(x, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Calculate Mean Absolute Deviation for a list of numbers.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean:\n    MAD = average(|x - x_mean|)\n    Args:\n        numbers (List[float]): A list of numeric values\n\n    Returns:\n        float: Mean Absolute Deviation\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    \"\"\"Returns the product of the unit digits of two integers.\"\"\"\n    return int(str(a)[-1] * str(b)[-1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[148, 412]], "plus_fail_tests": [[-6, -9]]}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p, handles numerics properly.\n\n    Args:\n        n (int): Exponent.\n        p (int): Modulus.\n\n    Returns:\n        int: 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x to the right by shift positions and return the result as a string.\n    If shift is greater than the number of digits, return the digits in reverse order.\n    \"\"\"\n    digits = str(x)\n    shift = shift % len(digits)  # Normalize shift value\n    return digits[-shift:] + digits[:-shift]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[1234, 6]]}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Rescales the provided list of numbers such that the smallest number becomes 0 and the largest becomes 1.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two elements\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n\n    return rescaled", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    \"\"\"Convert a decimal number to binary format and return it as a string with 'db' wrappers.\n\n    Parameters:\n    decimal (int): Number to be converted to binary.\n\n    Returns:\n    str: Converted number in binary format with 'db' wrappers.\n    \"\"\"\n    return \"db\" + bin(decimal)[2:] + \"db\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    \"\"\"Encrypt a string with a twice-doubled alphabet shift.\n\n    Args:\n        s (str): String to be encrypted.\n\n    Returns:\n        str: Encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            pos = alphabet.find(char)\n            encrypted += alphabet[(pos - shift) % 26]\n        else:\n            encrypted += char\n    return encrypted", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["hi"]], "plus_fail_tests": [["abcde"]]}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in the list.\n    If the list is empty, the sum should be 0 and the product should be 1.\n    \n    Parameters:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        Tuple[int, int]: A tuple containing sum and product of the list elements.\n    \"\"\"\n    sum = 0\n    product = 1\n    for num in numbers:\n        sum += num\n        product *= num\n    return (sum, product)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int):\n    return \" \".join([str(i) for i in range(n)])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0]], "plus_fail_tests": [[1]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    \"\"\"\n    Count elements with a sum of digits > 0.\n    \"\"\"\n    return sum(1 for num in arr if sum(int(dig) for dig in str(abs(num))) > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    '''\n    Returns the greatest integer with frequency >= the integer itself or -1 if none exist.\n    '''\n    if not lst:\n        return -1\n    \n    freq = {}\n    for num in lst:\n        freq[num] = freq.get(num, 0) + 1\n    \n    max_num = -1\n    for num, count in freq.items():\n        if count >= num:\n            max_num = max(max_num, num)\n    \n    return max_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    \"\"\"Return the word with the maximum number of unique characters.\n    If multiple strings have the maximum number of unique characters,\n    return the lexicographically smallest one.\n    \"\"\"\n    max_len = 0\n    result = \"\"\n    for word in words:\n        if len(set(word)) > max_len:\n            max_len = len(set(word))\n            result = word\n        elif len(set(word)) == max_len and word < result:\n            result = word\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int):\n    \"\"\"\n    Returns the number of collisions in the car race scenario.\n    \"\"\"\n    return n * (n - 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly four positive even numbers.\n    Returns:\n        bool: True if n can be written as the sum of 4 even numbers, otherwise False.\n    \"\"\"\n    # Check if n is even\n    if n % 2 != 0:\n        return False\n\n    # Iterate over even numbers and check if their sum equals n\n    for i in range(2, n // 2 + 1, 2):\n        if (n - i) % 4 == 0:\n            return True\n\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[6]], "plus_fail_tests": [[6]]}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    result = []\n    for word in lst:\n        if len(word) % 2 == 0:\n            result.append(word)\n    result.sort(key=lambda x: (len(x), x))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"Sums up two integers x and y.\n\n    Args:\n        x (int): The first integer.\n        y (int): The second integer.\n\n    Returns:\n        int: Sum of two integers.\n    \"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef intersection(interval1, interval2):\n    \"\"\"Determine if the length of the intersection is a prime number\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Check if the intervals intersect\n    if end1 < start2 or end2 < start1:\n        return \"NO\"\n    \n    # Find the length of the intersection\n    intersect_start = max(start1, start2)\n    intersect_end = min(end1, end2)\n\n    length = intersect_end - intersect_start + 1\n\n    return \"YES\" if is_prime(length) else \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    \"\"\"Computes the average of integers from n to m, rounds to nearest integer,\n    converts to binary and returns the result or -1 if n > m.\n    \"\"\"\n    if n > m:\n        return -1\n    avg = sum(range(n, m + 1)) / (m - n + 1)\n    rounded = round(avg)\n    binary = bin(rounded)[2:]\n    return f\"0b{binary}\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    '''\n    Returns the closest integer to the given value, rounding away from zero\n    if the number is equidistant from two integers.\n    '''\n    num = round(float(value))\n    if abs(num - int(value)) == 0.5:\n        return max(num, int(value))\n    return int(value)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["14.5"]], "plus_fail_tests": [["-2.8"]]}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "def median(l: list):\n    \"\"\"Compute the median of the list l. \n    The median of an even-length list is the average of the two middle numbers.\n    \n    Args:\n        l (list): A list of numerical values.\n        \n    Returns:\n        float or int: Median of the list.\n    \"\"\"\n    sorted_l = sorted(l)\n    mid = len(sorted_l) // 2\n    if len(sorted_l) % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str):\n    \"\"\" Check if brackets are correctly matched.\n        brackets is a string of \"<\" and \">\".\n        \n        Args:\n            brackets (str): String with '<' and '>' characters.\n        \n        Returns:\n            bool: True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(\"<\")\n        elif len(stack) > 0 and stack[-1] == \">\":\n            stack.pop()\n        else:\n            return False\n    return not len(stack)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["<>"]], "plus_fail_tests": [["<<<>>>"]]}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    '''\n    Splits the input string on different delimiters and returns the resulting words as a list. \n    The priority of the delimiters is as follows: space, comma ','. \n    If no such characters exist in the input, returns the number of lower-case letters with odd order in the alphabet.\n    '''\n    # split on spaces\n    words = txt.split()\n    if words:\n        return words\n    \n    # split on commas\n    words = txt.split(',')\n    if words:\n        return words\n    \n    # count odd ordered lower-case letters\n    return sum(1 for c in txt if c.lower() and ord(c) % 2 == 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello,world!"]], "plus_fail_tests": [["Hello?"]]}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    \"\"\"Return a dictionary of the most repetitive letters and their counts.\n    \n    Args:\n        test (str): Space separated lowercase letters.\n        \n    Returns:\n        dict: A dictionary containing the most frequent letters and their counts.\n    \"\"\"\n    hist = {}\n    for c in test.split():\n        hist[c] = hist.get(c, 0) + 1\n\n    max_count = max(hist.values())\n    result = {}\n    for letter, count in hist.items():\n        if count == max_count:\n            result[letter] = count\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [[""]]}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"Check if the string is happy.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        bool: True if string is happy, False otherwise. Happy string has length at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    return len(s) >= 3 and all(s[i] != s[i + 1] != s[i + 2] for i in range(len(s) - 2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["iopaxioi"]], "plus_fail_tests": [["agbebf"]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "def derivative(xs):\n    \"\"\" Compute derivative of the polynomial represented by xs.\n    Args:\n        xs (list): Coefficients of the polynomial.\n\n    Returns:\n        list: Coefficients of the derivative polynomial.\n    \"\"\"\n    ds = [0] * len(xs)\n    for i in range(1, len(xs)):\n        ds[i - 1] = i * xs[i]\n\n    return ds", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 1, 2, 4, 5]]], "plus_fail_tests": [[[0, 0, 0, 0, 0, 5]]]}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "def eat(number, need, remaining):\n    \"\"\"\n    Solves the hungry rabbit problem.\n    Args:\n        number (int): Number of carrots already eaten.\n        need (int): Number of carrots to be eaten.\n        remaining (int): Remaining carrots in stock.\n\n    Returns:\n        List[int]: [Total eaten carrots, Remaining carrots after eating]\n    \"\"\"\n    total_eaten = number + remaining\n    if total_eaten >= need:\n        return [need, remaining - (need - number)]\n    else:\n        return [total_eaten, 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 6, 10]], "plus_fail_tests": [[10, 0, 10]]}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Count the number of distinct characters in a string while ignoring case.\n    \n    Args:\n        string (str): Input string.\n        \n    Returns:\n        int: Number of distinct characters.\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"Returns a list of words with exactly n consonants.\n\n    Args:\n        s (str): Input string containing words separated by spaces.\n        n (int): Number of consonants to filter by.\n\n    Returns:\n        list: Words with exactly n consonants, in order of appearance.\n\n    Examples:\n        >>> select_words(\"Mary had a little lamb\", 4)\n        ['little']\n\n        >>> select_words(\"Mary had a little lamb\", 3)\n        ['Mary', 'lamb']\n\n        >>> select_words(\"simple white space\", 2)\n        []\n\n        >>> select_words(\"Hello world\", 4)\n        ['world']\n\n        >>> select_words(\"Uncle sam\", 3)\n        ['Uncle']\n    \"\"\"\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonants = 0\n        for char in word:\n            if char.isalpha():\n                consonants += 1\n        if consonants == n:\n            result.append(word)\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Mary had a little lamb", 4]], "plus_fail_tests": [["apple banana cherry", 3]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n\n    Args:\n        n (int): The position of the desired Fibonacci number.\n\n    Returns:\n        int: Desired Fibonacci number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parses the music string into a list of integers representing the number of beats.\n\n    Legend:\n    'o' - whole note, 4 beats\n    'o|' - half note, 2 beats\n    '.|' - quarter note, 1 beat\n\n    Parameters:\n    music_string (str): String in the special ASCII format.\n\n    Returns:\n    List[int]: List of integers corresponding to the number of beats.\n    \"\"\"\n    music = music_string.split(' ')\n    beats = []\n    legend = {'o': 4, 'o|': 2, '.|': 1}\n\n    for note in music:\n        beats.append(legend[note])\n\n    return beats", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [[""]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "def sum_squares(lst):\n    \"\"\"Returns the sum of squared numbers in the list after rounding each element to the upper integer value.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: Sum of squared numbers.\n    \"\"\"\n    return sum(int(x) ** 2 for x in lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.4, 4.2, 0]]], "plus_fail_tests": [[[0, 3.3, 7.7, -2.2]]]}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "def add_elements(arr, k):\n    \"\"\"\n    Return the sum of elements with at most two digits from the first 'k' elements of 'arr'.\n\n    Args:\n        arr (list): A non-empty array of integers.\n        k (int): An integer specifying the number of elements to consider from the start of the array.\n\n    Returns:\n        int: The sum of elements with at most two digits.\n    \"\"\"\n    return sum(x for x in arr[:k] if len(str(x)) <= 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-99, -88, -77, -66, -55, -44, -33, -22, -11], 5]]}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    \"\"\"\n    Sort the list of integers by the sum of their digits and their original index.\n    \"\"\"\n    nums_with_scores = [(sum(int(d) for d in str(num)), nums.index(num), num) for num in nums]\n    nums_with_scores.sort()\n    return [num for _, _, num in nums_with_scores]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    \"\"\"\n    Replaces all spaces in the input string with underscores, and if there are more than 2 \n    consecutive spaces, replaces them with a dash -.\n    \"\"\"\n    import re\n\n    return re.sub(\" +\", \"-\", text.replace(\" \", \"_\"))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Exa   mple"]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "def max_element(l: list):\n    \"\"\"Return the maximum element in the list.\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        int: Maximum element in the list.\n    \"\"\"\n    max_val = float('-inf')\n    for num in l:\n        if num > max_val:\n            max_val = num\n    return max_val", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "def sort_even(l: list):\n    \"\"\"Sorts the values of a list l at the even indices only.\n\n    Args:\n        l (list): Target list to be sorted.\n\n    Returns:\n        list: A new list with even indices sorted and odd indices unchanged.\n    \"\"\"\n    l_even = l[::2]\n    sorted_even = sorted(l_even)\n    result = l.copy()\n    result[::2] = sorted_even\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "def sort_third(l: list):\n    \"\"\"\n    Sorts the values of the list l that lie at indicies divisible by three, while keeping the other values unchanged.\n\n    Parameters:\n        l (list): The input list.\n\n    Returns:\n        list: A new list with the values at indices divisible by three sorted, and the other values unchanged.\n    \"\"\"\n    l_new = l.copy()\n    third_indices = [i for i in range(len(l_new)) if i % 3 == 0]\n\n    values_at_third_indices = [l_new[idx] for idx in third_indices]\n    sorted_values = sorted(values_at_third_indices)\n\n    for idx, val in enumerate(sorted_values):\n        l_new[third_indices[idx]] = val\n\n    return l_new", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "def add(lst):\n    \"\"\"Add elements at odd indices that are even.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    return sum(x for index, x in enumerate(lst) if index % 2 == 1 and x % 2 == 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings only for ones that start with a given prefix.\n    \n    Args:\n        strings (List[str]): The input list of strings.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: A new list containing only the strings that start with the given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    \"\"\"Returns the closest vowel between two consonants from the right side of the word.\n    Vowels in the beginning or ending do not count. \n    Returns empty string if no such vowel is found. \n    \"\"\"\n    vowels = \"AEIOUaeiou\"\n    last_consonant = None\n    for c in word[::-1]:\n        if c in vowels:\n            return c\n        else:\n            last_consonant = c\n            \n    return \"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["easy"]], "plus_fail_tests": [["hello"]]}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "def flip_case(s):\n    \"\"\"Flips the case of a string, converting uppercase to lowercase and vice versa.\n    \"\"\"\n    return ''.join([char.upper() if char.islower() else char.lower() for char in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "def special_factorial(n):\n    \"\"\"Returns the Brazilian factorial of integer n.\n\n    Brazilian factorial is defined as:\n    special_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\n    Parameters:\n        n (int): Positive integer for which to calculate the special factorial.\n\n    Returns:\n        int: The special factorial of the input integer.\n    \"\"\"\n    if n <= 0:\n        return 0\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[3]]}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers are any two numbers closer to each other than\n    the given threshold.\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_nums = sorted(numbers)\n    for i in range(1, len(sorted_nums)):\n        if sorted_nums[i] - sorted_nums[i - 1] < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "import math\ndef max_fill(grid, capacity):\n    \"\"\"\n    Solves the bucket lowering problem.\n    \n    Args:\n        grid (list): A list of lists representing the wells, where 1 denotes a unit of water.\n        capacity (int): The capacity of the buckets.\n        \n    Returns:\n        int: Number of times the bucket needs to be lowered.\n    \"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    steps = 0\n    \n    for r in range(rows):\n        col = 0\n        while col < cols:\n            if grid[r][col] == 1:\n                # Find the next column with water, if any\n                next_col = col + 1\n                while next_col < cols and grid[r][next_col] == 0:\n                    next_col += 1\n                \n                num_buckets = math.ceil((grid[r][col] + grid[r][next_col - 1]) / capacity)\n                steps += num_buckets\n                col = next_col\n            else:\n                col += 1\n    \n    return steps", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    \"\"\"\n    Evaluates the algebraic expression built using the operator and operand lists.\n    \"\"\"\n    assert len(operator) == len(operand) - 1\n    assert all(isinstance(num, int) and num >= 0 for num in operand)\n    assert len(operator) >= 1 and len(operand) >= 2\n\n    result = operand[0]\n    for op, num in zip(operator, operand[1:]):\n        result = {\"+\": lambda x: result + x,\n                 \"-\": lambda x: result - x,\n                 \"*\": lambda x: result * x,\n                 \"//\": lambda x: result // x,\n                 \"**\": lambda x: result ** x}[op](num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["+", "*", "-"], [2, 3, 4, 5]]], "plus_fail_tests": [[["+", "-", "*", "//"], [5, 2, 3, 4, 7]]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "def words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing words from the input sentence whose lengths are prime numbers,\n    preserving the original order.\n    \"\"\"\n    prime_words = []\n    words = sentence.split()\n\n    for word in words:\n        length = len(word)\n        if length > 1 and all(length % i for i in range(2, length)):\n            prime_words.append(word)\n\n    return ' '.join(prime_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\n    Transforms elements of the list based on their index and then sums up the resulting values.\n    Squares the element if the index is a multiple of 3 and cubes it if the index is a multiple of 4 but not a multiple of 3.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of the transformed values in the list.\n    \"\"\"\n    return sum(x**2 if i % 3 == 0 else x**3 if i % 4 == 0 and i % 3 != 0 else x  for i, x in enumerate(lst))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Compares two variables of type int, float, or str representing real numbers\n    and returns the larger one. Returns None if they're equal.\n    \"\"\"\n    if type(a) == type(b):\n        if isinstance(a, int):\n            return max(a, b)\n        elif isinstance(a, float):\n            return max(a, b)\n        elif a.replace(',', '.').replace('.', ',').lower() == b.lower():\n            return None\n        else:\n            return max(a, b)\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 2.5]], "plus_fail_tests": [[3, 3]]}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return the two closest numbers \n    in the list and return them in order (smaller number first, larger number second).\n\n    Parameters:\n        numbers (List[float]): A list of at least two float numbers.\n\n    Returns:\n        Tuple[float, float]: Two closest numbers in the list in order.\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must have at least two numbers\")\n\n    min_dist = numbers[1] - numbers[0]  # Initialize min distance between first two elements\n    closest_elements = (numbers[0], numbers[1])  # Initialize closest elements\n\n    for i in range(1, len(numbers) - 1):  # Iterate through the list, skipping first and last elements\n        left_dist = numbers[i] - numbers[i - 1]\n        right_dist = numbers[i + 1] - numbers[i]\n\n        if left_dist < min_dist:\n            min_dist = left_dist\n            closest_elements = (numbers[i - 1], numbers[i])\n\n        if right_dist < min_dist:\n            min_dist = right_dist\n            closest_elements = (numbers[i], numbers[i + 1])\n\n    return closest_elements", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1.0, 2.0, 3.9, 4.0, 5.0, 2.2]]], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    \"\"\"Returns True if x * n evaluates to a whole number, False otherwise.\n    Both x and n are in the form <numerator>/<denominator>.\"\"\"\n    x_num, x_denom = map(int, x.split('/'))\n    n_num, n_denom = map(int, n.split('/'))\n    if x_denom * n_num == x_num * n_denom:\n        return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1/5", "5/1"]], "plus_fail_tests": [["3/4", "4/3"]]}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def is_palindrome(s):\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return s == s[::-1]\ndef make_palindrome(string):\n    if is_palindrome(string):\n        return string\n    \n    # Omit the case of a single character palindrome\n    if len(string) > 1:\n        for i in range(1, len(string)):\n            suffix = string[-i:]\n            if is_palindrome(suffix):\n                prefix = string[:i][::-1]\n                return string + prefix\n               \n    return string + string[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["xyz"]], "plus_fail_tests": [["race"]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    \"\"\"Determine if it's possible to make lst1 have only even numbers with exchanges.\n\n    Args:\n        lst1 (list): A list of integers.\n        lst2 (list): Another list of integers.\n\n    Returns:\n        str: \"YES\" if possible to exchange for all even in lst1, otherwise \"NO\".\n    \"\"\"\n    odd_in_lst1 = [x for x in lst1 if x % 2 != 0]\n    return \"YES\" if len(odd_in_lst1) <= len(lst2) else \"NO\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4]]], "plus_fail_tests": [[[1, 3, 5, 7], [5, 7, 9, 11]]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    \"\"\"\n    Count the number of even and odd integer palindromes between 1 and n inclusive.\n\n    Parameters:\n        n (int): Upper limit of the range.\n\n    Returns:\n        tuple: A tuple containing the count of even and odd integer palindromes.\n    \"\"\"\n    even, odd = 0, 0\n\n    # Palindrome with a single digit\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n\n    # Palindrome with two digits\n    for i in range(10, n + 1):\n        temp = i\n        reversed_i = 0\n        while temp > 0:\n            reversed_i = reversed_i * 10 + temp % 10\n            temp //= 10\n        if i == reversed_i:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n\n    return (even, odd)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[123]], "plus_fail_tests": [[1000]]}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(number):\n    \"\"\"\n    Converts a positive integer to a lowercase mini Roman numeral.\n\n    Restrictions: 1 <= num <= 1000\n\n    Parameters:\n    number (int): The positive integer to convert.\n\n    Returns:\n    str: Roman numeral string.\n    \"\"\"\n    rom_val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    rom_sym = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    result = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // rom_val[i]):\n            result += rom_sym[i]\n            number -= rom_val[i]\n        i += 1\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[19]], "plus_fail_tests": [[111]]}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(word):\n    \"\"\"\n    Count the number of vowels in a word. 'Y' is considered a vowel only if it's the last letter.\n\n    Parameters:\n        word (str): A string representing a word.\n\n    Returns:\n        int: Number of vowels in the word.\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n\n    if len(word) > 0:\n        if word[-1] == 'y':\n            word = word[:-1]\n\n        for char in word.lower():\n            if char in vowels:\n                count += 1\n\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["key"]], "plus_fail_tests": [["candy"]]}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    \"\"\"\n    Count the number of boredoms in a string of words. A boredom is a sentence \n    that starts with \"I\".\n    \"\"\"\n    bored_count = 0\n    sentence_start = True\n\n    for c in S:\n        if c == '.' or c == '?' or c == '!':\n            sentence_start = True\n\n        if sentence_start and c == 'I':\n            bored_count += 1\n            sentence_start = False\n\n        if c == ' ':\n            sentence_start = False\n\n    return bored_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["I am very happy today. I love spending time with my friends."]]}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Returns the even digits between a and b (inclusive).\n    Assumes a and b are positive integers.\n\n    Parameters:\n    a (int): The lower bound of the range.\n    b (int): The upper bound of the range.\n\n    Returns:\n    list: Even digits in the range [a, b], sorted in ascending order.\n    \"\"\"\n    even_digits = []\n    for n in range(a, b + 1):\n        num_str = str(n)\n        if int(num_str.even()) and not num_str.startswith('0'):\n            even_digits.append(int(num_str))\n    return sorted(even_digits)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 10]], "plus_fail_tests": [[6, 12]]}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    '''\n    Returns the list with the total number of characters in all strings less than the other list.\n    \n    If the lists have the same total number of characters, the first list is returned.\n    '''\n    total_chars_lst1 = sum([len(x) for x in lst1])\n    total_chars_lst2 = sum([len(x) for x in lst2])\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["hi", "admin"], ["hI", "hi", "hii"]]], "plus_fail_tests": [[["happy", "birthday", "sarah"], ["happy", "birthday", "sally"]]]}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"Calculate the area of a triangle given side length 'a' and height 'h'.\n\n    Args:\n        a (float): Length of the side.\n        h (float): Height of the triangle.\n\n    Returns:\n        float: Area of the triangle.\n    \"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a given list of integers, generate a list of the rolling maximum element found \n    until that moment in the sequence.\n    \n    Args:\n        numbers (List[int]): A list of integers\n\n    Returns:\n        List[int]: A list containing the rolling maximum values\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_values = [numbers[0]]\n    max_val = numbers[0]\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_val:\n            max_val = numbers[i]\n            rolling_max_values.append(max_val)\n        else:\n            rolling_max_values.append(rolling_max_values[-1])\n\n    return rolling_max_values", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "import re\ndef valid_date(date):\n    \"\"\"Validate a date string based on multiple conditions.\n\n    Rules:\n    1. Date string should not be empty.\n    2. Days: 1-31 for Jan, Mar, May, Jul, Aug, Oct, Dec. 1-30 for Apr, Jun, Sep, Nov. 1-29 for Feb.\n    3. Months: 1-12.\n    4. Format: mm-dd-yyyy\n\n    Returns:\n        bool: True if valid, False otherwise.\n    \"\"\"\n    # Check if date string matches the required format\n    if not re.match(r\"^\\d{2}-\\d{2}-\\d{4}$\", date):\n        return False\n\n    month, day, year = map(int, date.split(\"-\"))\n\n    # Validate days and months\n    if (\n        (month in [1, 3, 5, 7, 8, 10, 12] and (day < 1 or day > 31))\n        or (month in [4, 6, 9, 11] and (day < 1 or day > 30))\n        or (month == 2 and (day < 1 or day > 29))\n        or month < 1 or month > 12\n    ):\n        return False\n\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["06-04-2020\n"]]}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if the given string is a palindrome.\n    This function uses a simple algorithm to compare the first and last characters \n    of the string and iteratively move towards the center.\n    Args:\n        text (str): String to check for palindrome property.\n\n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    left, right = 0, len(text) - 1\n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "import hashlib\ndef string_to_md5(text):\n    \"\"\"\n    Compute the md5 hash of an input string and return it as a string.\n\n    Args:\n        text (str): Input string to hash.\n\n    Returns:\n        str or None: Md5 hash as a hexadecimal representation string, or None for an empty string input.\n    \"\"\"\n    if not text:\n        return None\n    md5_hash = hashlib.md5()\n    md5_hash.update(text.encode())\n    return md5_hash.hexdigest()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(nums):\n    \"\"\"\n    Checks if there are two distinct elements in the list that sum up to zero.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        bool: True if such pair exists, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "def is_nested(s):\n    '''\n    Checks if a string containing only brackets has a nested bracket sequence.\n    '''\n    stack = []\n    for i in s:\n        if i == '[':\n            stack.append(i)\n        elif i == ']':\n            if len(stack) > 1 and stack[-2] == '[':\n                stack.pop()\n                stack.pop()\n            else:\n                return False\n        else:\n            raise Exception('Invalid input string')\n            \n    return len(stack) > 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]]"]], "plus_fail_tests": [["[[]][]"]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # intersect and sort the lists\n    return sorted(list(set(l1) & set(l2)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "def prime_fib(n: int):\n    \"\"\"\n    Finds the n-th Fibonacci number that is also a prime.\n    \"\"\"\n    fib_seq = [2, 3]\n    while len(fib_seq) < n + 1:\n        fib_seq.append(fib_seq[-1] + fib_seq[-2])\n        # Only keep numbers that are prime\n        if is_prime(fib_seq[-1]):\n            fib_seq.pop()\n\n    return fib_seq[n]\ndef is_prime(num: int) -> bool:\n    \"\"\"Check if num is a prime number.\"\"\"\n    if num == 2:\n        return True\n    if num <= 1 or num % 2 == 0:\n        return False\n\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[11]]}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    Args:\n        string (str): String to measure length\n\n    Returns:\n        int: Length of the string\n    \"\"\"\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "def fibfib(n):\n    \"\"\"Computes the n-th element of the fibfib number sequence:\n    fibfib(0) = 0\n    fibfib(1) = 0\n    fibfib(2) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    \"\"\"\n    if n <= 1:\n        return n\n    elif n == 2:\n        return 1\n    # The offset FibFib sequence starts with 0, 0, 1, so the actual index is n - 3.\n    fibs = [0, 0, 1]\n    for i in range(3, n + 1):\n        fibs.append(fibs[i - 1] + fibs[i - 2] + fibs[i - 3])\n    return fibs[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[1]]}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    \"\"\"\n    Find integer x in the 2d list and return sorted list of tuples.\n    \"\"\"\n    res = []\n    for i, row in enumerate(lst):\n        idx = row.index(x)\n        res.append((i, idx))\n    res.sort()\n    return res", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1]], "plus_fail_tests": [[[[], [], [], []], 10]]}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string, including overlapping cases.\n    \"\"\"\n    if not substring:  # Edge case: empty substring\n        return 0\n    index = 0\n    count = 0\n    while index < len(string):\n        index = string.find(substring, index)\n        if index == -1:\n            break\n        count += 1\n        index += len(substring)\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["cacacacac", "cac"]], "plus_fail_tests": [["ababa", "aba"]]}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    \"\"\"\n    Sort the array based on the condition specified.\n    Don't change the given array, return a sorted copy instead.\n    \"\"\"\n    sorted_array = array[:]\n    if sum(array[0], array[-1]) % 2 == 1:\n        sorted_array.sort()\n    else:\n        sorted_array.sort(reverse=True)\n    return sorted_array", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[]]], "plus_fail_tests": [[[0, 0, 0, 0]]]}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    '''\n    Checks if list of integers is sorted in ascending order and has no duplicates.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if list is sorted and has no duplicates. False otherwise.\n    '''\n    # Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if sorted\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\ndef concatenate(strings: List[str]):\n    \"\"\" \n    Concatenate list of strings into a single string\n    and return it.\n    \n    Args:\n        strings (List[str]): Strings to be concatenated.\n\n    Returns:\n        str: Concatenated string.\n    \"\"\"\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    \"\"\"Return an array showing the difference between the guess and the actual game score.\n    If the guess is correct, the value is 0.\n    \"\"\"\n    result = []\n    for i in range(len(game)):\n        result.append(abs(game[i] - guess[i]))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input string.\n\n    Args:\n        text (str): Input string.\n\n    Returns:\n        str: String without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([c for c in text if c not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "def pluck(arr):\n    \"\"\"\n    Plucks and returns the smallest even value from the tree branch array,\n    or returns [] if no even values or the array is empty.\n    Prioritizes the node with the smallest index in case of ties.\n    \"\"\"\n    even_nodes = [node for node in arr if node % 2 == 0]\n    if not even_nodes or not arr:\n        return []\n\n    smallest_even = min(even_nodes)\n    smallest_index = min([i for i, node in enumerate(arr) if node == smallest_even])\n\n    return [smallest_even, smallest_index]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    '''\n    Sort the list in a strange order.\n\n    Args:\n        lst (list): List of integers to be sorted.\n\n    Returns:\n        list: Sorted list in strange order.\n    '''\n    sorted_lst = []\n    min_val = float('inf')\n\n    # Find the minimum value in the list\n    for num in lst:\n        min_val = min(min_val, num)\n\n    # Strange sorting\n    while lst:\n        sorted_lst.append(min_val)\n        max_val = max(lst)\n        lst.remove(max_val)\n        min_val = min_val + 1\n\n    return sorted_lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4]]], "plus_fail_tests": [[[-5, 0, 5, 10]]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    \"\"\"\n    Sort array of non-negative integers based on ones in binary representation.\n    For same number of ones, sort by decimal value.\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "def solve(N):\n    \"\"\"Returns the sum of digits of N in binary.\n\n    Args:\n        N (int): A positive integer.\n\n    Returns:\n        str: Sum of digits in binary.\n    \"\"\"\n    sum_of_digits = sum(int(x) for x in str(N))\n    return bin(sum_of_digits)[2:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(numbers_list):\n    \"\"\"Returns a tuple with the largest negative integer and the smallest positive integer.\n\n    Args:\n        numbers_list (list): A list of integers with both positive and negative values.\n\n    Returns:\n        tuple: A tuple containing the largest negative integer and the smallest positive integer.\n                Both values are returned as None if the respective integers are not found.\n\n    Examples:\n        >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n        (None, 1)\n\n        >>> largest_smallest_integers([])\n        (None, None)\n\n        >>> largest_smallest_integers([0])\n        (None, None)\n    \"\"\"\n    largest_neg = None\n    smallest_pos = None\n\n    for num in numbers_list:\n        if num < 0:\n            if largest_neg is None or num > largest_neg:\n                largest_neg = num\n        elif num > 0:\n            if smallest_pos is None or num < smallest_pos:\n                smallest_pos = num\n\n    return largest_neg, smallest_pos", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Count the numbers of n-digit positive integers that start or end with 1.\n    \"\"\"\n    # Starting with 1\n    count = 9**n\n    # Ending with 1\n    count += 10**n - 11**n\n    \n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[6]]}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    depth_stack = []\n    max_depth_stack = []\n    tokens = paren_string.split()\n\n    for token in tokens:\n        if token == \"(\":\n            depth = 1\n            depth_stack.append(depth)\n            max_depth_stack.append(depth)\n        elif token == \")\":\n            depth_stack.pop()\n            max_depth = max(max_depth_stack)\n            max_depth_stack.append(max_depth)\n\n    return [max(depth_stack) for depth_stack in max_depth_stack]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(()()) ((())) () ((())()())"]], "plus_fail_tests": [["((()))"]]}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order of appearance.\n    Each factor is listed number of times it appears in factorization.\n    Input number should be equal to the product of all the factors.\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n\n    if n > 1:\n        factors.append(n)\n\n    return factors", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\" Insert a number 'delimiter' between every two consecutive elements of input list numbers\n    \"\"\"\n    result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimiter)\n        result.append(num)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Returns a sorted list of odd numbers in the Collatz sequence.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        list: A sorted list containing odd numbers in the Collatz sequence.\n    \"\"\"\n    sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        if n % 2 != 0:\n            sequence.append(n)\n    sequence.sort()\n    return sequence", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[14]], "plus_fail_tests": [[2]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    \"\"\"\n    Calculate the sum of magnitudes multiplied by the product of signs.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int or float or None: Sum of magnitudes with the product of signs, or None for an empty array.\n    \"\"\"\n    signs = [1 if a != 0 else 0 for a in arr]\n    magnitudes = [abs(a) for a in arr]\n\n    if not signs:  # Empty array\n        return None\n\n    prod = 1\n    for s in signs:\n        prod *= s\n\n    return prod * sum(magnitudes)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, -4]]], "plus_fail_tests": [[[-2, -2, -2, 4]]]}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below the threshold t.\n    \"\"\"\n    for num in l:\n        if num >= t:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    \"\"\"\n    Finds the minimum number of elements to change to make the array palindromic.\n\n    Args:\n        arr (list): An array of integers.\n\n    Returns:\n        int: The minimum number of elements that need to be changed.\n    \"\"\"\n    # O(n) time, O(n) space, where n is the length of arr\n    n = len(arr)\n    left, right = 0, n - 1\n    changes = 0\n\n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n            left += 1\n            right -= 1\n        else:\n            left += 1\n            right -= 1\n\n    return changes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n    \"\"\"\n    Finds the minimum path of length k in the grid.\n\n    Parameters:\n        - grid (list of lists): A grid with N rows and N columns.\n        - k (int): The length of the path.\n\n    Returns:\n        - list: An ordered list of the values on the cells \n            that the minimum path goes through.\n    \"\"\"\n    N = len(grid)\n    path = []\n    visited = set()\n\n    def dfs(x, y, current_path):\n        if len(current_path) == k:\n            path.extend(current_path)\n            return\n\n        current_path.append(grid[x][y])\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                dfs(nx, ny, current_path[:])\n                visited.remove((nx, ny))\n        current_path.pop()\n\n    for x in range(N):\n        for y in range(N):\n            if (x, y) not in visited:\n                visited.add((x, y))\n                dfs(x, y, [grid[x][y]])\n                visited.remove((x, y))\n\n    return path", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1]]}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Checks if the last character of a string is an alphabetical \n    character and is not part of a word.\n\n    Parameters:\n    txt (str): Input string.\n\n    Returns:\n    bool: True if the last char is an alphabetical character \n    and is not part of a word, False otherwise.\n    '''\n    words = txt.split()\n    last_char = txt[-1]\n\n    if len(words) == 0:\n        return False\n\n    if len(words) == 1:\n        return txt[-1].isalpha()\n\n    return words[-1][-1].isalpha()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["apple"]], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    '''\n    Calculates the sum of squares of odd integers in the list, ignoring negative numbers and non-integers.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        int: Sum of squares of odd numbers or 0 if the list is empty.\n    '''\n    return sum(x**2 for x in lst if x > 0 and isinstance(x, int) and x % 2 != 0) or 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Returns the maximum k numbers from the given array.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): Number of maximum elements to return.\n\n    Returns:\n        list: A sorted list containing the maximum k numbers from the input array.\n    \"\"\"\n    max_k_nums = sorted(arr)[-k:]\n    return max_k_nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, -23, 243, -400, 0], 0]], "plus_fail_tests": [[[1], 0]]}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "def iscube(a):\n    '''\n    Checks if integer a is a cube of some integer number.\n    '''\n    # Cube roots are always positive, so we can ignore the sign\n    a = abs(a) \n    root = a ** (1/3)\n    return root.is_integer()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[64]], "plus_fail_tests": [[125]]}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    letter_grades = {\n        4.0: 'A+',\n        'A': 3.7,\n        'A-': 3.3,\n        'B+': 3.0,\n        'B': 2.7,\n        'B-': 2.3,\n        'C+': 2.0,\n        'C': 1.7,\n        'C-': 1.3,\n        'D+': 1.0,\n        'D': 0.7,\n        'D-': 0.0,\n        'E': 0.0\n    }\n    result = []\n    for grade in grades:\n        for l, h in letter_grades.items():\n            if grade >= h:\n                result.append(l)\n                break\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": [[[3.8, 2.5, 3.9, 2.2, 1.0]]]}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str):\n    \"\"\" Returns True if every opening bracket has a corresponding closing bracket.\n    Args:\n        brackets (str): String containing only '(' and ')' characters.\n\n    Returns:\n        bool: True if correctly bracketted, False otherwise.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif not stack or stack[-1] != '(' :\n            return False\n        else:\n            stack.pop()\n    return not stack", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n    \"\"\"Returns True if x is a simple power of n, False otherwise.\n    A simple power has integer exponent.\n    \"\"\"\n    return x == n**int(math.log(x, n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[16, 2]], "plus_fail_tests": [[25, 5]]}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n > 1 which is not a prime.\"\"\"\n    if n % 2 == 0:\n        return 2\n    # Use the fact that all odd numbers greater than 2 can be written as 6k \u00b1 1\n    for k in range(1, (n - 1) // 3 + 1):\n        if n % (6 * k) == 1:\n            return 6 * k - 1\n        elif n % (6 * k) == 5:\n            return 6 * k + 1\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15]], "plus_fail_tests": [[100]]}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "def count_up_to(n):\n    primes = []\n    for num in range(2, n + 1):\n        # simple optimization, skip middle five numbers,\n        # since they are unlikely to be prime\n        if num % 2 == 0 or num % 5 == 0:\n            continue\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n        if is_prime:\n            primes.append(num)\n    return primes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[3]]}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    # Delete characters in s that are in c\n    s = ''.join([x for x in s if x not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = s == s[::-1]\n    \n    return s, is_palindrome", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "def Strongest_Extension(class_name, extensions):\n    def calc_strength(name):\n        return sum(1 for char in name if char.isupper()) - sum(1 for char in name if char.islower())\n\n    strongest = max(extensions, key=calc_strength)\n    return f\"{class_name}.{strongest}\"", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    \"\"\"\n    choices = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    numbers = numbers.split()\n    numbers.sort(key=choices.index)\n    return ' '.join(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\ndef find_zero(xs: list):\n    \"\"\"\n    Finds a zero point of a polynomial with given coefficients xs.\n    The function returns one zero point, even if there are multiple ones.\n    It's guaranteed to work if xs has even number of elements and\n    the highest non-zero coefficient.\n    \"\"\"\n    # Ensure the highest non-zero coefficient is at the end\n    non_zero_idx = next((i for i, x in enumerate(xs) if x != 0), len(xs))\n    xs = xs[non_zero_idx:] + xs[:non_zero_idx]\n\n    # Use the fact that polynomial has x=0 as a root\n    # and use backward substitution\n    x_n = 1 / math.pow(xs[-1], -1)\n    for i in range(len(xs) - 1, 0, -1):\n        x_i = x_n * (-xs[i] / xs[i + 1])\n        x_n = x_i + math.pow(x_i, len(xs) - i - 1)\n    return x_i", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": [[[5, 10, -3, 1]]]}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return a list of all prefixes of the input string from shortest to longest.\n    \"\"\"\n    prefixes = []\n    prefix = \"\"\n    for char in string:\n        prefix += char\n        prefixes.append(prefix)\n    return prefixes[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["asdfgh"]], "plus_fail_tests": [["Hello there!"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    \"\"\"Returns the largest index of an element which is not greater than or\n    equal to the previous element in the given array. If no such element is\n    found, return -1.\n\n    Args:\n        arr (list): A list of integers with no duplicates.\n\n    Returns:\n        int: Largest index of an element fulfilling the condition or -1.\n    \"\"\"\n    max_idx = -1\n    for idx in range(len(arr) - 1):\n        if arr[idx] >= arr[idx + 1]:\n            max_idx = idx\n    return max_idx", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 4, 3, 5]]], "plus_fail_tests": [[[5, 4, 3, 2, 1]]]}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "def bf(planet1, planet2):\n    '''\n    Returns a tuple containing planets with orbits between planet1 and planet2.\n    '''\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    planet1_index = planets.index(planet1)\n    planet2_index = planets.index(planet2)\n    \n    if planet1_index or planet2_index == -1:\n        return ()\n\n    left = planet1_index\n    right = planet2_index\n\n    result = []\n    for planet in planets[left:right+1]:\n        result.append(planet)\n\n    return tuple(sorted(result, key=planets.index))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Jupiter", "Neptune"]], "plus_fail_tests": [["Neptune", "Mercury"]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Count uppercase vowels in even indices.\n    \n    Args:\n        s (str): Input string.\n        \n    Returns:\n        int: Number of uppercase vowels in even indices.\n    \"\"\"\n    vowels = \"AEIOUaeiou\"\n    count = 0\n    for idx in range(len(s)):\n        if s[idx] in vowels and idx % 2 == 0:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aBCdEf"]], "plus_fail_tests": [["abcDEf"]]}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    \"\"\"\n    Changes case of letters and reverses non-letter characters.\n    Reverses the string if no letters are present.\n    \n    Args:\n        s (str): Input string.\n        \n    Returns:\n        str: Processed string.\n    \"\"\"\n    letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    result = ''\n    rev = False\n\n    for char in s:\n        if char in letters:\n            result += letters[(letters.lower().index(char.lower()) + 15) % 52]\n        else:\n            rev = not rev\n            result += char\n\n    return result[::-1] if rev else result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["AsDf"]], "plus_fail_tests": [["ABCDEFG"]]}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def hex_key(hex_str):\n    \"\"\"Count prime hexadecimal digits in hex_str.\"\"\"\n    primes = 0\n    for digit in hex_str:\n        if digit in '2357BD':\n            primes += 1\n    return primes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    Detect if account balance falls below zero at any point.\n    Returns True if it does, False otherwise.\n    \"\"\"\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Multiply Prime\n    if n < 100:\n        count = 0\n        for i in range(2, int(n ** (1/2)) + 1):\n            if is_prime(i) and is_prime(n // i):\n                count += 1\n        return count == 2\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[30]], "plus_fail_tests": [[99]]}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\"\"\"\n    return [i for i in l if i > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    \"\"\"Returns the sum of odd integers in even positions.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: Sum of odd elements in even positions.\n\n    Examples:\n        >>> solution([5, 8, 7, 1])\n        12\n        >>> solution([3, 3, 3, 3, 3])\n        9\n        >>> solution([30, 13, 24, 321])\n        0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(numbers):\n    \"\"\"\n    Returns the second smallest element or None if not found.\n    \"\"\"\n    if len(numbers) < 2:\n        return None\n    \n    numbers = sorted(numbers)\n    return numbers[1] if numbers[0] != numbers[1] else None", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 2, 2, 2, 2, 2, 3, 3, 3, 3]]]}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "def f(n):\n    \"\"\" Returns a list of size n with the element at index i being the factorial of i if i is even,\n    or the sum of numbers from 1 to i if i is odd.\n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result\ndef factorial(n):\n    \"\"\"Returns the factorial of n.\"\"\"\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes the message by swapping cases of all letters and replacing vowels \n    with the letter that appears two places ahead in the alphabet.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(\n        char.upper() if char.islower() else char.lower() \n        for char in message \n        if char in vowels \n        for i in range(2)\n        ).replace('A', 'M').replace('E', 'H').replace('I', 'O')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    \"\"\"\n    Distributes fruits from a basket described in a string into apples, oranges, and mangoes.\n\n    Parameters:\n    s (str): Description of the number of apples and oranges in the format \"X apples and Y oranges\".\n    n: Total number of fruits in the basket.\n\n    Returns:\n    int: Number of mangoes in the basket.\n    \"\"\"\n    # Split the sentence to extract numbers.\n    words = s.split() \n    apples = int(words[0].replace(\"apples\", \"\"))\n    oranges = int(words[3].replace(\"oranges\", \"\"))\n\n    # Calculate the number of mangoes.\n    return n - apples - oranges", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    \"\"\"\n    Determine if the array can be sorted by right shifts.\n\n    Args:\n        arr (list): A list of integers with unique elements.\n\n    Returns:\n        bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    if not arr:  # Edge case: Empty array\n        return True\n    \n    max_val = max(arr)\n    idx = arr.index(max_val)\n\n    # Check if the max value can be moved to the front\n    for i in range(idx, -1, -1):\n        if arr[i] < max_val:\n            return False\n    \n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": [[[5, 6, 7, 8, 1, 2, 3, 4]]]}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    '''\n    Checks if two strings consisting of only parentheses can be concatenated \n    to form a balanced string.\n    '''\n    open_count = lst[0].count('(')\n    close_count = lst[1].count(')')\n\n    if open_count == close_count:\n        return 'Yes'\n    else:\n        return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["()(", ")"]]], "plus_fail_tests": [[["()()", "()()()"]]]}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Construct a pile of stones with n levels following the problem statement.\n    \"\"\"\n    result = []\n    if n % 2 == 1:  # Odd number of stones in the first level\n        current_stones = n\n        while current_stones != 1:\n            result.append(current_stones)\n            current_stones = (current_stones + 1) // 2  # Move to next odd number\n    else:  # Even number of stones in the first level\n        current_stones = n\n        while current_stones > 1:\n            result.append(current_stones)\n            current_stones //= 2  # Move to next even number\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1]]}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"Returns a sorted list of elements with unique digits from the given list of positives.\n\n    Args:\n        x (list): A list of positive integers.\n\n    Returns:\n        list: A sorted list of integers with unique digits.\n    \"\"\"\n    result = []\n    for num in x:\n        has_even_digit = any(int(char) % 2 == 0 for char in str(num))\n        if not has_even_digit:\n            result.append(num)\n    result.sort()\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(encoded_str: str):\n    \"\"\"\n    Decodes a string encoded with the encode_cyclic function.\n    \"\"\"\n    # Split the encoded string into groups of 3 characters.\n    groups = [encoded_str[i:i + 3] for i in range(0, len(encoded_str), 3)]\n    \n    # Iterate over each group and move the first character to the end.\n    decoded_groups = [''.join([group[1], group[2], group[0]]) for group in groups]\n    \n    # Join the decoded groups to form the original string.\n    return ''.join(decoded_groups)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["uzfplzjfzcltmdly"]], "plus_fail_tests": [["abcdefghijk"]]}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" \n    Filter an input list of strings and return only the ones containing the given substring.\n\n    Args:\n        strings (List[str]): The input list of strings.\n        substring (str): Substring to filter by. Must not be empty.\n\n    Returns:\n        List[str]: Filtered list of strings.\n    \"\"\"\n    if not substring:\n        raise ValueError(\"Substring argument must not be empty\")\n\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], ""]]}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Separate balanced parentheses groups in the input string and return them as a list.\n\n    Args:\n        paren_string (str): Input string containing nested parentheses groups.\n\n    Returns:\n        List[str]: A list of strings representing separate groups.\n    \"\"\"\n    result = []\n    brace_stack = []\n    for char in paren_string:\n        if char == '(':\n            brace_stack.append('(')\n        elif char == ')':\n            if brace_stack:\n                brace_stack.pop()\n                group = ''.join(brace_stack)\n                result.append(group)\n            else:\n                brace_stack.append(')')\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(()()) ((())) () ((())()())"]], "plus_fail_tests": [["()"]]}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "def odd_count(lst):\n    return [f\"the number of odd elements {len([x for x in s if x % 2 != 0])}n the str{len([x for x in s if x % 2 != 0])}ng {i} of the {len([x for x in s if x % 2 != 0])}nput.\" \n            for i, s in enumerate(lst)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["1234567"]]], "plus_fail_tests": [[["2468"]]]}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"Returns true if n is a prime number, and false otherwise.\n    Prime numbers are positive integers greater than 1 that have no positive divisors other than 1 and themselves.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return sorted(s0) == sorted(s1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["eabcdzzzz", "dddzzzzzzzddeddabc"]], "plus_fail_tests": [["aaabbbccc", "abbabcbc"]]}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int):\n    \"\"\"This function calculates the sum of numbers from 1 to n.\n    \n    Args:\n        n (int): The upper limit of the sum range.\n        \n    Returns:\n        int: The sum of numbers from 1 to n.\n    \"\"\"\n    return sum(range(1, n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform binary XOR on the two input strings consisting only of 1s and 0s and return the result as a string.\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must have equal length.\")\n\n    result = \"\"\n    for i in range(len(a)):\n        result += str((int(a[i]) ^ int(b[i])))\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    Splits a string of words separated by commas or spaces into an array of words.\n\n    Args:\n        s (str): String of words separated by commas or spaces.\n\n    Returns:\n        list: Words as a list of strings.\n    \"\"\"\n    return s.split()[::2] + s.split(',')[1::2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hi, my name is John"]], "plus_fail_tests": [[",,,,"]]}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    \"\"\"Return a tuple with counts of even and odd digits in 'num' respectively.\n\n    Args:\n        num (int): Target number.\n\n    Returns:\n        tuple: Even and odd digit counts.\n    \"\"\"\n    even, odd = 0, 0\n    num = abs(num)  # Ensure positive number\n    digits = str(num)\n    for digit in digits:\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return even, odd", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "def prime_length(string):\n    \"\"\"Returns True if the length of the string is a prime number, False otherwise.\"\"\"\n    length = len(string)\n    for num in range(2, length):\n        if length % num == 0:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [["a"]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    Checks if there are three distinct elements in the list that sum up to zero.\n\n    Args:\n        l (list): A list of integers.\n\n    Returns:\n        bool: True if such elements exist, False otherwise.\n    \"\"\"\n    # Create a dictionary with element counts\n    count_dict = {}\n    for num in l:\n        count_dict[num] = count_dict.get(num, 0) + 1\n\n    # Check for three distinct elements with zero sum\n    for num1 in count_dict:\n        if count_dict[num1] > 1:\n            for num2 in count_dict:\n                if num1 != num2 and count_dict[num2] > 0:\n                    opposite = -num1 - num2\n                    if opposite in count_dict and count_dict[opposite] > 0:\n                        return True\n\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, -5, 3, 9, 7]]], "plus_fail_tests": [[[0, 0, 0]]]}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Finds the minimum sum of any non-empty subarray.\n    Args:\n        nums (list): The input list of integers.\n    Returns:\n        int: Minimum sum of any subarray.\n    \"\"\"\n    if not nums:\n        return 0  # Handle empty list\n    min_sum = float('inf')\n    start = 0\n    for end in range(len(nums)):\n        min_sum = min(min_sum, nums[end])\n        # Move the start index until we find a smaller number than min_sum\n        while nums[start] > min_sum:\n            min_sum = min(min_sum, nums[start])\n            start += 1\n        # Now min_sum is the minimum sum of the current subarray\n        # ending at end and starting at start\n    return min_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, -3]]], "plus_fail_tests": [[[2, 4, -1, 3, 5, -4, 1, -2]]]}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    \"\"\"Returns the sum of ASCII codes of uppercase digits in the input string.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        int: Sum of ASCII codes of uppercase characters.\n    \"\"\"\n    return sum(ord(c) for c in s if c.isupper())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    '''\n    Checks if the three sides form a right angle triangle.\n    '''\n    return a**2 == b**2 + c**2 or b**2 == a**2 + c**2 or c**2 == a**2 + b**2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "def triangle_area(a, b, c):\n    '''\n    Calculates the area of a triangle given its three sides. \n    Returns the area rounded to 2 decimal places if the sides form a valid triangle, \n    else returns -1.\n    '''\n    # Check if the triangle is valid\n    if a + b > c and a + c > b and b + c > a:\n        area = (a + b + c) / 4\n        return round(area, 2)\n    else:\n        return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4, 5]], "plus_fail_tests": [[8, 9, 15]]}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    '''\n    Checks if one number is the sum of the other two and all numbers are integers.\n    \n    Parameters:\n    x (int): A number.\n    y (int): A number.\n    z (int): A number.\n    \n    Returns:\n    bool: True if one number is the sum of the other two, and all numbers are integers, otherwise False.\n    '''\n    if not all(isinstance(i, int) for i in [x, y, z]):\n        return False\n    \n    s = x + y\n    return s == z or s == x or s == y", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 1]], "plus_fail_tests": [[-2, 5, 7]]}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int):\n    \"\"\"Convert numbers to different bases.\n    Args:\n        x (int): number to convert\n        base (int): base to convert x to, base < 10\n    Returns:\n        str: x converted to the specified base\n    \"\"\"\n    x = bin(x)[2:]  # Get the binary representation of x\n    return ''.join([change_base_helper(int(d)) for d in x[::-1]])\ndef change_base_helper(x: int):\n    return str(x % base) if x < base else chr(x % base + 48)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8, 3]], "plus_fail_tests": [[10, 5]]}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(d):\n    \"\"\"\n    Checks if all keys in the dictionary are in lower or upper case and returns False \n    if the dictionary is empty.\n    \"\"\"\n    if not d:\n        return False\n    lower_case_check = all(isinstance(key, str) and key.islower() for key in d)\n    upper_case_check = all(isinstance(key, str) and key.isupper() for key in d)\n    return lower_case_check or upper_case_check", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    Decodes a string encoded with encode_shift function.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Reorders the words in the input string such that the words are rearranged \n    based on their ASCII values while maintaining their relative order.\n\n    Parameters:\n        s (str): Input string with multiple words.\n\n    Returns:\n        str: Reordered string with words sorted by ASCII values.\n    \"\"\"\n    words = s.split()\n    sorted_words = [sorted(word, key=lambda x: x.lower()) for word in words]\n    return ' '.join(sorted_words)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hi"]], "plus_fail_tests": [["12345"]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    Args:\n        l (list): Target list to check for monotonic properties.\n\n    Returns:\n        bool: True if the list is monotonically increasing or decreasing, False otherwise.\n    \"\"\"\n    # Check for special case of empty list\n    if len(l) == 0:\n        return False\n\n    # Check for increasing monotonicity\n    if l[0] <= l[1]:\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n\n    # Check for decreasing monotonicity\n    return all(l[i] >= l[i - 1] for i in range(1, len(l)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 1, 0, -10]]], "plus_fail_tests": [[[10, 9, 8, 7, 6]]]}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "def is_prime(n):\n    \"\"\"Check if input number n is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef x_or_y(n, x, y):\n    \"\"\"Return x if n is prime, else return y.\"\"\"\n    return x if is_prime(n) else y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"Returns the largest even integer in the range [x, y] or -1 if none exist.\n\n    Args:\n        x (int): Lower bound of the range.\n        y (int): Upper bound of the range. Must be greater than x.\n\n    Returns:\n        int: Largest even integer in the range [x, y] or -1.\n    \"\"\"\n    if y < x:\n        raise ValueError(\"Invalid input range\")\n    even_numbers = [num for num in range(x, y + 1) if num % 2 == 0]\n    if even_numbers:\n        return max(even_numbers)\n    else:\n        return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[13, 12]], "plus_fail_tests": [[100, 6]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    def count_triples(num):\n        # Count the number of triples for the given num\n        count = 0\n        for i in range(1, num // 3 + 1):\n            for j in range(2 * i, num // 2 + 1, i):\n                k = num - i - j\n                count += 1\n        return count\n\n    # Use the count_triples function to calculate the answer\n    return count_triples(n * (n + 1) // 2 - 1)  # Formula for sum of first n natural numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[3]]}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    '''\n    Checks if an object will fly based on balance and weight.\n\n    Parameters:\n    q (list): A list representing the object's weight distribution.\n    w (int): The maximum possible weight.\n\n    Returns:\n    bool: True if the object will fly, False otherwise.\n    '''\n    # Check if the list is palindromic\n    if q == q[::-1]:\n        # Check if the sum of the elements is less than or equal to the maximum weight\n        return sum(q) <= w\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}